<!--
Copyright 2017 Next Century Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>client-config</title>
  <script src="../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../bower_components/web-component-tester/browser.js"></script>
  <link rel="import" href="../elements/client-config/client-config.html">
</head>

<body>
<test-fixture id="client-config-fixture">
  <template>
    <client-config></client-config>
  </template>
</test-fixture>

<script>
  'use strict';
  /* globals expect, fixture, setup, suite, test */
  /* jshint -W030 */

  suite('<client-config> search transform tests', function() {
    var clientConfig;

    var DEFAULT_QUERY = {
      SPARQL: {
        'group-by': undefined,
        select: {
          variables: [],
        },
        where: {
          clauses: [],
          filters: [],
          type: 'Ad',
          variable: '?ad'
        }
      },
      type: 'Point Fact'
    };

    var GROUP_BY = {
      limit: 50,
      offset: 0
    };

    setup(function() {
      clientConfig = fixture('client-config-fixture');
    });

    test('does define search transform function', function() {
      expect(clientConfig).to.exist;
      expect(clientConfig.config).to.exist;
      expect(clientConfig.config.transforms).to.exist;
      expect(clientConfig.config.transforms.search).to.exist;
      expect(clientConfig.config.transforms.search.search).to.be.a('Function');
    });

    test('search transform function given empty input does return default query', function() {
      expect(clientConfig.config.transforms.search.search()).to.deep.equal(DEFAULT_QUERY);
      expect(clientConfig.config.transforms.search.search(1)).to.deep.equal(DEFAULT_QUERY);
      expect(clientConfig.config.transforms.search.search(1, 50)).to.deep.equal(DEFAULT_QUERY);
      expect(clientConfig.config.transforms.search.search(1, 50, {})).to.deep.equal(DEFAULT_QUERY);
    });

    test('search transform function given page size above 1 does return correct query', function() {
      var data = {
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          }
        }
      };

      expect(clientConfig.config.transforms.search.search(2, 50, data).SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 50
      });

      expect(clientConfig.config.transforms.search.search(2, 100, data).SPARQL['group-by']).to.deep.equal({
        limit: 100,
        offset: 100
      });

      expect(clientConfig.config.transforms.search.search(5, 50, data).SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 200
      });

      expect(clientConfig.config.transforms.search.search(5, 100, data).SPARQL['group-by']).to.deep.equal({
        limit: 100,
        offset: 400
      });
    });

    test('search transform function given search parameters of same type does return correct query', function() {
      var output = clientConfig.config.transforms.search.search(1, 50, {
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          },
          titleB: {
            enabled: true,
            key: 'titleB'
          }
        }
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal(GROUP_BY);
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?title1'
        }, {
          type: 'simple',
          variable: '?title2'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        constraint: 'titleB',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?title1',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?title2',
        isOptional: true,
        predicate: 'title'
      }]);
    });

    test('search transform function given disabled search parameters does return correct query', function() {
      var output = clientConfig.config.transforms.search.search(1, 50, {
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          },
          titleB: {
            enabled: false,
            key: 'titleB'
          }
        }
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal(GROUP_BY);
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?title1'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?title1',
        isOptional: true,
        predicate: 'title'
      }]);
    });

    test('search transform function given search parameters of multiple types does return correct query', function() {
      var output = clientConfig.config.transforms.search.search(1, 50, {
        age: {
          ageA: {
            enabled: true,
            key: 'ageA'
          }
        },
        city: {
          cityA: {
            enabled: true,
            key: 'cityA'
          }
        },
        country: {
          countryA: {
            enabled: true,
            key: 'countryA'
          }
        },
        description: {
          descriptionA: {
            enabled: true,
            key: 'descriptionA'
          }
        },
        email: {
          emailA: {
            enabled: true,
            key: 'emailA'
          }
        },
        ethnicity: {
          ethnicityA: {
            enabled: true,
            key: 'ethnicityA'
          }
        },
        eyeColor: {
          eyeColorA: {
            enabled: true,
            key: 'eyeColorA'
          }
        },
        gender: {
          genderA: {
            enabled: true,
            key: 'genderA'
          }
        },
        hairColor: {
          hairColorA: {
            enabled: true,
            key: 'hairColorA'
          }
        },
        height: {
          heightA: {
            enabled: true,
            key: 'heightA'
          }
        },
        name: {
          nameA: {
            enabled: true,
            key: 'nameA'
          }
        },
        phone: {
          phoneA: {
            enabled: true,
            key: 'phoneA'
          }
        },
        price: {
          priceA: {
            enabled: true,
            key: 'priceA'
          }
        },
        region: {
          regionA: {
            enabled: true,
            key: 'regionA'
          }
        },
        review: {
          reviewA: {
            enabled: true,
            key: 'reviewA'
          }
        },
        services: {
          serviceA: {
            enabled: true,
            key: 'serviceA'
          }
        },
        social: {
          socialA: {
            enabled: true,
            key: 'socialA'
          }
        },
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          }
        },
        website: {
          websiteA: {
            enabled: true,
            key: 'websiteA'
          }
        },
        weight: {
          weightA: {
            enabled: true,
            key: 'weightA'
          }
        }
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal(GROUP_BY);
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?age1'
        }, {
          type: 'simple',
          variable: '?city1'
        }, {
          type: 'simple',
          variable: '?country1'
        }, {
          type: 'simple',
          variable: '?description1'
        }, {
          type: 'simple',
          variable: '?email1'
        }, {
          type: 'simple',
          variable: '?ethnicity1'
        }, {
          type: 'simple',
          variable: '?eye_color1'
        }, {
          type: 'simple',
          variable: '?gender1'
        }, {
          type: 'simple',
          variable: '?hair_color1'
        }, {
          type: 'simple',
          variable: '?height1'
        }, {
          type: 'simple',
          variable: '?name1'
        }, {
          type: 'simple',
          variable: '?phone1'
        }, {
          type: 'simple',
          variable: '?price1'
        }, {
          type: 'simple',
          variable: '?state1'
        }, {
          type: 'simple',
          variable: '?review_id1'
        }, {
          type: 'simple',
          variable: '?service1'
        }, {
          type: 'simple',
          variable: '?social_media_id1'
        }, {
          type: 'simple',
          variable: '?title1'
        }, {
          type: 'simple',
          variable: '?tld1'
        }, {
          type: 'simple',
          variable: '?weight1'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'ageA',
        isOptional: true,
        predicate: 'age'
      }, {
        constraint: 'cityA',
        isOptional: true,
        predicate: 'city'
      }, {
        constraint: 'countryA',
        isOptional: true,
        predicate: 'country'
      }, {
        constraint: 'descriptionA',
        isOptional: true,
        predicate: 'description'
      }, {
        constraint: 'emailA',
        isOptional: true,
        predicate: 'email'
      }, {
        constraint: 'ethnicityA',
        isOptional: true,
        predicate: 'ethnicity'
      }, {
        constraint: 'eyeColorA',
        isOptional: true,
        predicate: 'eye_color'
      }, {
        constraint: 'genderA',
        isOptional: true,
        predicate: 'gender'
      }, {
        constraint: 'hairColorA',
        isOptional: true,
        predicate: 'hair_color'
      }, {
        constraint: 'heightA',
        isOptional: true,
        predicate: 'height'
      }, {
        constraint: 'nameA',
        isOptional: true,
        predicate: 'name'
      }, {
        constraint: 'phoneA',
        isOptional: true,
        predicate: 'phone'
      }, {
        constraint: 'priceA',
        isOptional: true,
        predicate: 'price'
      }, {
        constraint: 'regionA',
        isOptional: true,
        predicate: 'state'
      }, {
        constraint: 'reviewA',
        isOptional: true,
        predicate: 'review_id'
      }, {
        constraint: 'serviceA',
        isOptional: true,
        predicate: 'service'
      }, {
        constraint: 'socialA',
        isOptional: true,
        predicate: 'social_media_id'
      }, {
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        constraint: 'websiteA',
        isOptional: true,
        predicate: 'tld'
      }, {
        constraint: 'weightA',
        isOptional: true,
        predicate: 'weight'
      }, {
        variable: '?age1',
        isOptional: true,
        predicate: 'age'
      }, {
        variable: '?city1',
        isOptional: true,
        predicate: 'city'
      }, {
        variable: '?country1',
        isOptional: true,
        predicate: 'country'
      }, {
        variable: '?description1',
        isOptional: true,
        predicate: 'description'
      }, {
        variable: '?email1',
        isOptional: true,
        predicate: 'email'
      }, {
        variable: '?ethnicity1',
        isOptional: true,
        predicate: 'ethnicity'
      }, {
        variable: '?eye_color1',
        isOptional: true,
        predicate: 'eye_color'
      }, {
        variable: '?gender1',
        isOptional: true,
        predicate: 'gender'
      }, {
        variable: '?hair_color1',
        isOptional: true,
        predicate: 'hair_color'
      }, {
        variable: '?height1',
        isOptional: true,
        predicate: 'height'
      }, {
        variable: '?name1',
        isOptional: true,
        predicate: 'name'
      }, {
        variable: '?phone1',
        isOptional: true,
        predicate: 'phone'
      }, {
        variable: '?price1',
        isOptional: true,
        predicate: 'price'
      }, {
        variable: '?state1',
        isOptional: true,
        predicate: 'state'
      }, {
        variable: '?review_id1',
        isOptional: true,
        predicate: 'review_id'
      }, {
        variable: '?service1',
        isOptional: true,
        predicate: 'service'
      }, {
        variable: '?social_media_id1',
        isOptional: true,
        predicate: 'social_media_id'
      }, {
        variable: '?title1',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?tld1',
        isOptional: true,
        predicate: 'tld'
      }, {
        variable: '?weight1',
        isOptional: true,
        predicate: 'weight'
      }]);
    });

    test('search transform function given date search parameters does return correct query', function() {
      var output = clientConfig.config.transforms.search.search(1, 50, {
        postingDate: {
          dateStart: {
            enabled: true,
            date: 'start'
          },
          dateEnd: {
            enabled: true,
            date: 'end'
          }
        }
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal(GROUP_BY);
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?date1'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        operator: 'and',
        clauses: [{
          constraint: 'start',
          operator: '>',
          variable: '?date1'
        }, {
          constraint: 'end',
          operator: '<',
          variable: '?date1'
        }]
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        variable: '?date1',
        isOptional: false,
        predicate: 'posting_date'
      }]);
    });

    test('search transform function given both enabled and disabled date search parameters does return correct query', function() {
      var output = clientConfig.config.transforms.search.search(1, 50, {
        postingDate: {
          dateStart: {
            enabled: true,
            date: 'start'
          },
          dateEnd: {
            enabled: false,
            date: 'end'
          }
        }
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal(GROUP_BY);
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?date1'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        operator: 'and',
        clauses: [{
          constraint: 'start',
          operator: '>',
          variable: '?date1'
        }]
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        variable: '?date1',
        isOptional: false,
        predicate: 'posting_date'
      }]);
    });
  });
</script>
</body>
</html>
