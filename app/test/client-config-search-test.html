<!--
Copyright 2017 Next Century Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>client-config</title>
  <script src="../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../bower_components/web-component-tester/browser.js"></script>
  <link rel="import" href="../elements/client-config/client-config.html">
</head>

<body>
<test-fixture id="client-config-fixture">
  <template>
    <client-config></client-config>
  </template>
</test-fixture>

<script>
  'use strict';
  /* globals fixture, suite, setup, test, assert, expect */
  /* jshint -W030 */

  suite('<client-config> search transform tests', function() {
    var clientConfig;

    /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
    var cityResponse = [{
      result: {
        aggregations: {
          '?city': {
            buckets: [{
              key: 'Ontario:California:United States:-117.65089:34.06334',
              doc_count: 11
            }, {
              key: 'Los Angeles:California:United States:-118.24368:34.05223',
              doc_count: 10
            }, {
              key: 'Mumbai:State of Maharashtra:India:72.88261:19.07283',
              doc_count: 10
            }, {
              key: 'Melbourne:Florida:United States:-80.60811:28.08363',
              doc_count: 9
            }, {
              key: 'Bakersfield:California:United States:-119.01871:35.37329',
              doc_count: 8
            }, {
              key: 'Dallas:Texas:United States:-96.80667:32.78306',
              doc_count: 8
            }, {
              key: 'Shanghai:Shanghai Shi:China:121.45806:31.22222',
              doc_count: 8
            }, {
              key: 'Miami:Florida:United States:-80.19366:25.77427',
              doc_count: 7
            }, {
              key: 'New York:New York:United States:-74.00597:40.71427',
              doc_count: 7
            }, {
              key: 'Oklahoma City:Oklahoma:United States:-97.51643:35.46756',
              doc_count: 7
            }]
          }
        }
      }
    }];

    var cityNetworkExpansionResponse = [{
      result: [{
        // some query results here from first query
      }, {
        // network expansion query results
        aggregations: {
          '?city': {
            buckets: [{
              key: 'Ontario:California:United States:-117.65089:34.06334',
              doc_count: 11
            }, {
              key: 'Los Angeles:California:United States:-118.24368:34.05223',
              doc_count: 10
            }, {
              key: 'Mumbai:State of Maharashtra:India:72.88261:19.07283',
              doc_count: 10
            }, {
              key: 'Melbourne:Florida:United States:-80.60811:28.08363',
              doc_count: 9
            }, {
              key: 'Bakersfield:California:United States:-119.01871:35.37329',
              doc_count: 8
            }, {
              key: 'Dallas:Texas:United States:-96.80667:32.78306',
              doc_count: 8
            }, {
              key: 'Shanghai:Shanghai Shi:China:121.45806:31.22222',
              doc_count: 8
            }, {
              key: 'Miami:Florida:United States:-80.19366:25.77427',
              doc_count: 7
            }, {
              key: 'New York:New York:United States:-74.00597:40.71427',
              doc_count: 7
            }, {
              key: 'Oklahoma City:Oklahoma:United States:-97.51643:35.46756',
              doc_count: 7
            }]
          }
        }
      }]
    }];

    var compoundResponse = [{
      result: {
        aggregations: {
          '?property': {
            buckets: [{
              key: '175',
              doc_count: 80
            }, {
              key: '175-unit:centimeter',
              doc_count: 40
            }, {
              key: '175-time_unit:60',
              doc_count: 20
            }, {
              key: '175-currency:dollars',
              doc_count: 10
            }, {
              key: '175-currency:dollars-time_unit:60',
              doc_count: 5
            }]
          }
        }
      }
    }];

    var compoundNetworkExpansionResponse = [{
      result: [{
        // some query results here from first query
      }, {
        // network expansion query results
        aggregations: {
          '?property': {
            buckets: [{
              key: '175',
              doc_count: 80
            }, {
              key: '175-unit:centimeter',
              doc_count: 40
            }, {
              key: '175-time_unit:60',
              doc_count: 20
            }, {
              key: '175-currency:dollars',
              doc_count: 10
            }, {
              key: '175-currency:dollars-time_unit:60',
              doc_count: 5
            }]
          }
        }
      }]
    }];

    var emailResponse = [{
      result: {
        aggregations: {
          '?email': {
            buckets: [{
              key: 'abc@gmail.com',
              doc_count: 20
            }, {
              key: 'xyz@gmail.com',
              doc_count: 10
            }, {
              key: 'abc@yahoo.com',
              doc_count: 5
            }]
          }
        }
      }
    }];

    var emailNetworkExpansionResponse = [{
      result: [{
        // some query results here from first query
      }, {
        // network expansion query results
        aggregations: {
          '?email': {
            buckets: [{
              key: 'abc@gmail.com',
              doc_count: 20
            }, {
              key: 'xyz@gmail.com',
              doc_count: 10
            }, {
              key: 'abc@yahoo.com',
              doc_count: 5
            }]
          }
        }
      }]
    }];

    var filterResponse = [{
      result: {
        aggregations: {
          '?property': {
            buckets: [{
              key: 123,
              doc_count: 20
            }, {
              key: 'UPPERCASE',
              doc_count: 10
            }, {
              key: 'lowercase',
              doc_count: 5
            }]
          }
        }
      }
    }];

    var filterNetworkExpansionResponse = [{
      result: [{
        // some query results here from first query
      }, {
        // network expansion query results
        aggregations: {
          '?property': {
            buckets: [{
              key: 123,
              doc_count: 20
            }, {
              key: 'UPPERCASE',
              doc_count: 10
            }, {
              key: 'lowercase',
              doc_count: 5
            }]
          }
        }
      }]
    }];

    var phoneResponse = [{
      result: {
        aggregations: {
          '?phone': {
            buckets: [{
              key: '1234567890',
              doc_count: 80
            }, {
              key: '+1-1112223333',
              doc_count: 40
            }, {
              key: '+2-4445556666',
              doc_count: 20
            }, {
              key: '+1234-7778889999',
              doc_count: 10
            }, {
              key: '+x-9876543210',
              doc_count: 5
            }]
          }
        }
      }
    }];

    var phoneNetworkExpansionResponse = [{
      result: [{
        // some query results here from first query
      }, {
        // network expansion query results
        aggregations: {
          '?phone': {
            buckets: [{
              key: '1234567890',
              doc_count: 80
            }, {
              key: '+1-1112223333',
              doc_count: 40
            }, {
              key: '+2-4445556666',
              doc_count: 20
            }, {
              key: '+1234-7778889999',
              doc_count: 10
            }, {
              key: '+x-9876543210',
              doc_count: 5
            }]
          }
        }
      }]
    }];

    var socialMediaResponse = [{
      result: {
        aggregations: {
          '?social_media_id': {
            buckets: [{
              key: 'twitter user123',
              doc_count: 80
            }, {
              key: 'twitter user456',
              doc_count: 40
            }, {
              key: 'twitter user789',
              doc_count: 20
            }, {
              key: 'instagram userABC',
              doc_count: 10
            }, {
              key: 'userXYZ',
              doc_count: 5
            }]
          }
        }
      }
    }];

    var socialMediaNetworkExpansionResponse = [{
      result: [{
        // some query results here from first query
      }, {
        // network expansion query results
        aggregations: {
          '?social_media_id': {
            buckets: [{
              key: 'twitter user123',
              doc_count: 80
            }, {
              key: 'twitter user456',
              doc_count: 40
            }, {
              key: 'twitter user789',
              doc_count: 20
            }, {
              key: 'instagram userABC',
              doc_count: 10
            }, {
              key: 'userXYZ',
              doc_count: 5
            }]
          }
        }
      }]
    }];

    /* jscs:enable requireCamelCaseOrUpperCaseIdentifiers */

    setup(function() {
      clientConfig = fixture('client-config-fixture');
      clientConfig.config = {};
    });

    test('does define adQuery transform function', function() {
      expect(clientConfig).to.exist;
      expect(clientConfig.config).to.exist;
      expect(clientConfig.transforms).to.exist;
      expect(clientConfig.transforms.search).to.exist;
      expect(clientConfig.transforms.search.adQuery).to.be.a('Function');
    });

    test('adQuery transform function given empty input does return default query', function() {
      var DEFAULT_AD_QUERY = {
        SPARQL: {
          'group-by': undefined,
          select: {
            variables: [{
              type: 'simple',
              variable: '?ad'
            }],
          },
          where: {
            clauses: [],
            filters: [],
            type: 'Ad',
            variable: '?ad'
          }
        },
        type: 'Point Fact'
      };

      expect(clientConfig.transforms.search.adQuery()).to.deep.equal(DEFAULT_AD_QUERY);
      expect(clientConfig.transforms.search.adQuery({})).to.deep.equal(DEFAULT_AD_QUERY);
      expect(clientConfig.transforms.search.adQuery({}, {})).to.deep.equal(DEFAULT_AD_QUERY);
    });

    test('adQuery transform function given page and page size does return correct query', function() {
      expect(clientConfig.transforms.search.adQuery({}, {
        page: 2,
        pageSize: 50
      }).SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 50
      });

      expect(clientConfig.transforms.search.adQuery({}, {
        page: 2,
        pageSize: 100
      }).SPARQL['group-by']).to.deep.equal({
        limit: 100,
        offset: 100
      });

      expect(clientConfig.transforms.search.adQuery({}, {
        page: 5,
        pageSize: 50
      }).SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 200
      });

      expect(clientConfig.transforms.search.adQuery({}, {
        page: 5,
        pageSize: 100
      }).SPARQL['group-by']).to.deep.equal({
        limit: 100,
        offset: 400
      });
    });

    test('adQuery transform function given search parameters of same type does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          },
          titleB: {
            enabled: true,
            key: 'titleB'
          }
        }
      }, {
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        constraint: 'titleB',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?title1',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?title2',
        isOptional: true,
        predicate: 'title'
      }]);
    });

    test('adQuery transform function given disabled search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          },
          titleB: {
            enabled: false,
            key: 'titleB'
          }
        }
      }, {
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?title1',
        isOptional: true,
        predicate: 'title'
      }]);
    });

    test('adQuery transform function given search parameters of multiple types does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        age: {
          ageA: {
            enabled: true,
            key: 'ageA'
          }
        },
        city: {
          cityA: {
            enabled: true,
            key: 'cityA'
          }
        },
        country: {
          countryA: {
            enabled: true,
            key: 'countryA'
          }
        },
        description: {
          descriptionA: {
            enabled: true,
            key: 'descriptionA'
          }
        },
        email: {
          emailA: {
            enabled: true,
            key: 'emailA'
          }
        },
        ethnicity: {
          ethnicityA: {
            enabled: true,
            key: 'ethnicityA'
          }
        },
        eyeColor: {
          eyeColorA: {
            enabled: true,
            key: 'eyeColorA'
          }
        },
        gender: {
          genderA: {
            enabled: true,
            key: 'genderA'
          }
        },
        hairColor: {
          hairColorA: {
            enabled: true,
            key: 'hairColorA'
          }
        },
        height: {
          heightA: {
            enabled: true,
            key: 'heightA'
          }
        },
        name: {
          nameA: {
            enabled: true,
            key: 'nameA'
          }
        },
        phone: {
          phoneA: {
            enabled: true,
            key: 'phoneA'
          }
        },
        price: {
          priceA: {
            enabled: true,
            key: 'priceA'
          }
        },
        region: {
          regionA: {
            enabled: true,
            key: 'regionA'
          }
        },
        review: {
          reviewA: {
            enabled: true,
            key: 'reviewA'
          }
        },
        services: {
          serviceA: {
            enabled: true,
            key: 'serviceA'
          }
        },
        social: {
          socialA: {
            enabled: true,
            key: 'socialA'
          }
        },
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          }
        },
        website: {
          websiteA: {
            enabled: true,
            key: 'websiteA'
          }
        },
        weight: {
          weightA: {
            enabled: true,
            key: 'weightA'
          }
        }
      }, {
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'ageA',
        isOptional: true,
        predicate: 'age'
      }, {
        constraint: 'cityA',
        isOptional: true,
        predicate: 'city'
      }, {
        constraint: 'countryA',
        isOptional: true,
        predicate: 'country'
      }, {
        constraint: 'descriptionA',
        isOptional: true,
        predicate: 'description'
      }, {
        constraint: 'emailA',
        isOptional: true,
        predicate: 'email'
      }, {
        constraint: 'ethnicityA',
        isOptional: true,
        predicate: 'ethnicity'
      }, {
        constraint: 'eyeColorA',
        isOptional: true,
        predicate: 'eye_color'
      }, {
        constraint: 'genderA',
        isOptional: true,
        predicate: 'gender'
      }, {
        constraint: 'hairColorA',
        isOptional: true,
        predicate: 'hair_color'
      }, {
        constraint: 'heightA',
        isOptional: true,
        predicate: 'height'
      }, {
        constraint: 'nameA',
        isOptional: true,
        predicate: 'name'
      }, {
        constraint: 'phoneA',
        isOptional: true,
        predicate: 'phone'
      }, {
        constraint: 'priceA',
        isOptional: true,
        predicate: 'price'
      }, {
        constraint: 'regionA',
        isOptional: true,
        predicate: 'state'
      }, {
        constraint: 'reviewA',
        isOptional: true,
        predicate: 'review_id'
      }, {
        constraint: 'serviceA',
        isOptional: true,
        predicate: 'service'
      }, {
        constraint: 'socialA',
        isOptional: true,
        predicate: 'social_media_id'
      }, {
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        constraint: 'websiteA',
        isOptional: true,
        predicate: 'website'
      }, {
        constraint: 'weightA',
        isOptional: true,
        predicate: 'weight'
      }, {
        variable: '?age1',
        isOptional: true,
        predicate: 'age'
      }, {
        variable: '?city1',
        isOptional: true,
        predicate: 'city'
      }, {
        variable: '?country1',
        isOptional: true,
        predicate: 'country'
      }, {
        variable: '?description1',
        isOptional: true,
        predicate: 'description'
      }, {
        variable: '?email1',
        isOptional: true,
        predicate: 'email'
      }, {
        variable: '?ethnicity1',
        isOptional: true,
        predicate: 'ethnicity'
      }, {
        variable: '?eye_color1',
        isOptional: true,
        predicate: 'eye_color'
      }, {
        variable: '?gender1',
        isOptional: true,
        predicate: 'gender'
      }, {
        variable: '?hair_color1',
        isOptional: true,
        predicate: 'hair_color'
      }, {
        variable: '?height1',
        isOptional: true,
        predicate: 'height'
      }, {
        variable: '?name1',
        isOptional: true,
        predicate: 'name'
      }, {
        variable: '?phone1',
        isOptional: true,
        predicate: 'phone'
      }, {
        variable: '?price1',
        isOptional: true,
        predicate: 'price'
      }, {
        variable: '?state1',
        isOptional: true,
        predicate: 'state'
      }, {
        variable: '?review_id1',
        isOptional: true,
        predicate: 'review_id'
      }, {
        variable: '?service1',
        isOptional: true,
        predicate: 'service'
      }, {
        variable: '?social_media_id1',
        isOptional: true,
        predicate: 'social_media_id'
      }, {
        variable: '?title1',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?website1',
        isOptional: true,
        predicate: 'website'
      }, {
        variable: '?weight1',
        isOptional: true,
        predicate: 'weight'
      }]);
    });

    test('adQuery transform function given both optional and required search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        email: {
          emailA: {
            enabled: true,
            key: 'emailA',
            search: 'optional'
          },
          emailB: {
            enabled: true,
            key: 'emailB',
            search: 'required'
          },
        },
        phone: {
          phoneA: {
            enabled: true,
            key: 'phoneA',
            search: 'required'
          },
          phoneB: {
            enabled: true,
            key: 'phoneB',
            search: 'optional'
          },
        }
      }, {
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'emailA',
        isOptional: true,
        predicate: 'email'
      }, {
        constraint: 'emailB',
        isOptional: false,
        predicate: 'email'
      }, {
        constraint: 'phoneA',
        isOptional: false,
        predicate: 'phone'
      }, {
        constraint: 'phoneB',
        isOptional: true,
        predicate: 'phone'
      }, {
        variable: '?email1',
        isOptional: true,
        predicate: 'email'
      }, {
        variable: '?email2',
        isOptional: false,
        predicate: 'email'
      }, {
        variable: '?phone1',
        isOptional: false,
        predicate: 'phone'
      }, {
        variable: '?phone2',
        isOptional: true,
        predicate: 'phone'
      }]);
    });

    test('adQuery transform function given excluded search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        email: {
          emailA: {
            enabled: true,
            key: 'emailA',
            search: 'optional'
          },
          emailB: {
            enabled: true,
            key: 'emailB',
            search: 'excluded'
          }
        },
        phone: {
          phoneA: {
            enabled: true,
            key: 'phoneA',
            search: 'excluded'
          },
          phoneB: {
            enabled: true,
            key: 'phoneB',
            search: 'optional'
          }
        }
      }, {
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        clauses: [{
          constraint: 'emailB',
          predicate: 'email'
        }, {
          constraint: 'phoneA',
          predicate: 'phone'
        }],
        operator: 'not exists'
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'emailA',
        isOptional: true,
        predicate: 'email'
      }, {
        constraint: 'phoneB',
        isOptional: true,
        predicate: 'phone'
      }, {
        variable: '?email1',
        isOptional: true,
        predicate: 'email'
      }, {
        variable: '?phone1',
        isOptional: true,
        predicate: 'phone'
      }]);
    });

    test('adQuery transform function given union search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        email: {
          emailA: {
            enabled: true,
            key: 'emailA',
            search: 'union'
          }
        },
        phone: {
          phoneA: {
            enabled: true,
            key: 'phoneA',
            search: 'union'
          },
          phoneB: {
            enabled: true,
            key: 'phoneB',
            search: 'union'
          },
          phoneC: {
            enabled: true,
            key: 'phoneC',
            search: 'excluded'
          }
        },
        title: {
          titleA: {
            enabled: true,
            key: 'titleA',
            search: 'optional'
          }
        }
      }, {
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        clauses: [{
          constraint: 'phoneC',
          predicate: 'phone'
        }],
        operator: 'not exists'
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        clauses: [{
          constraint: 'emailA',
          isOptional: false,
          predicate: 'email'
        }],
        operator: 'union'
      }, {
        clauses: [{
          constraint: 'phoneA',
          isOptional: false,
          predicate: 'phone'
        }, {
          constraint: 'phoneB',
          isOptional: false,
          predicate: 'phone'
        }],
        operator: 'union'
      }, {
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?title1',
        isOptional: true,
        predicate: 'title'
      }]);
    });

    test('adQuery transform function given date search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        postingDate: {
          dateStart: {
            enabled: true,
            date: 'start'
          },
          dateEnd: {
            enabled: true,
            date: 'end'
          }
        }
      }, {
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        operator: 'and',
        clauses: [{
          constraint: 'start',
          operator: '>=',
          variable: '?date1'
        }, {
          constraint: 'end',
          operator: '<=',
          variable: '?date1'
        }]
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        variable: '?date1',
        isOptional: false,
        predicate: 'posting_date'
      }]);
    });

    test('adQuery transform function given both enabled and disabled date search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        postingDate: {
          dateStart: {
            enabled: true,
            date: 'start'
          },
          dateEnd: {
            enabled: false,
            date: 'end'
          }
        }
      }, {
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        operator: 'and',
        clauses: [{
          constraint: 'start',
          operator: '>=',
          variable: '?date1'
        }]
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        variable: '?date1',
        isOptional: false,
        predicate: 'posting_date'
      }]);
    });

    test('adQuery transform function with network parameters does return correct query', function() {
      var output = clientConfig.transforms.search.adQuery({
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          }
        },
        email: {
          emailA: {
            enabled: true,
            key: 'emailA'
          }
        }
      }, {
        custom: {
          email: true
        },
        page: 1,
        pageSize: 50
      });

      expect(output.type).to.equal('Point Fact');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 50,
        offset: 0
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          type: 'simple',
          variable: '?ad2'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad2');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        clauses: [
          {
            constraint: 'titleA',
            isOptional: true,
            predicate: 'title'
          },
          {
            constraint: 'emailA',
            isOptional: true,
            predicate: 'email'
          },
          {
            isOptional: false,
            predicate: 'email',
            variable: '?email'
          }
        ],
        type: 'Ad',
        variable: '?ad1'
      },
      {
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      },
      {
        isOptional: false,
        predicate: 'email',
        variable: '?email'
      }]);
    });

    test('does define adResults transform function', function() {
      expect(clientConfig).to.exist;
      expect(clientConfig.config).to.exist;
      expect(clientConfig.transforms).to.exist;
      expect(clientConfig.transforms.search).to.exist;
      expect(clientConfig.transforms.search.adResults).to.be.a('Function');
    });

    test('adResults transform function given empty input does return an object', function() {
      expect(clientConfig.transforms.search.adResults()).to.deep.equal({
        fields: {},
        hits: {}
      });
      expect(clientConfig.transforms.search.adResults([])).to.deep.equal({
        fields: {},
        hits: {}
      });
      expect(clientConfig.transforms.search.adResults([{}])).to.deep.equal({
        fields: {},
        hits: {}
      });
      expect(clientConfig.transforms.search.adResults([{
        query: {},
        result: {}
      }])).to.deep.equal({
        fields: {},
        hits: []
      });
    });

    test('adResults transform function given a response with hits does return an object with hits', function() {
      expect(clientConfig.transforms.search.adResults([{
        result: {
          hits: {
            hits: [1, 2, 3],
            total: 3,
          }
        }
      }])).to.deep.equal({
        fields: {},
        hits: {
          hits: [1, 2, 3],
          total: 3
        }
      });
    });

    test('adResults transform function given a response with clauses and hits does return an object with fields and hits', function() {
      expect(clientConfig.transforms.search.adResults([{
        query: {
          SPARQL: {
            where: {
              clauses: [{
                '_id': 'idA',
                constraint: 'constraintA',
                predicate: 'age'
              }, {
                '_id': 'idB',
                constraint: 'constraintB',
                predicate: 'age'
              }, {
                '_id': 'idC',
                constraint: 'constraintC',
                predicate: 'social_media_id'
              }]
            }
          }
        },
        result: {
          hits: {
            hits: [1, 2, 3],
            total: 3
          }
        }
      }])).to.deep.equal({
        fields: {
          age: {
            constraintA: 'idA',
            constraintB: 'idB'
          },
          social: {
            constraintC: 'idC'
          }
        },
        hits: {
          hits: [1, 2, 3],
          total: 3
        }
      });
    });

    test('adResults transform function for a network expansion query returns correct response', function() {
      expect(clientConfig.transforms.search.adResults([{
        result: [{
          hits: {
            hits: [1, 2],
            total: 2
          },
        }, {
          hits: {
            hits: [3, 4, 5, 6],
            total: 4
          }
        }]
      }], {
        networkExpansionQuery: true
      })).to.deep.equal({
        fields: {},
        hits: {
          hits: [3, 4, 5, 6],
          total: 4
        }
      });
    });

    test('adResults transform function for a network expansion query given a network expansion response with clauses and hits does return an object with fields and hits', function() {
      expect(clientConfig.transforms.search.adResults([{
        query: {
          SPARQL: {
            where: {
              clauses: [{
                clauses: [{
                  '_id': 'idA',
                  constraint: 'constraintA',
                  predicate: 'age'
                }, {
                  '_id': 'idB',
                  constraint: 'constraintB',
                  predicate: 'age'
                }, {
                  '_id': 'idC',
                  constraint: 'constraintC',
                  predicate: 'social_media_id'
                }]
              }]
            }
          }
        },
        result: [{
          hits: {
            hits: [1, 2],
            total: 2
          },
        }, {
          hits: {
            hits: [3, 4, 5, 6],
            total: 4
          }
        }]
      }], {
        networkExpansionQuery: true
      })).to.deep.equal({
        fields: {
          age: {
            constrainta: 'idA',
            constraintb: 'idB'
          },
          social: {
            constraintc: 'idC'
          }
        },
        hits: {
          hits: [3, 4, 5, 6],
          total: 4
        }
      });
    });

    test('does define facetsQuery transform function', function() {
      expect(clientConfig).to.exist;
      expect(clientConfig.config).to.exist;
      expect(clientConfig.transforms).to.exist;
      expect(clientConfig.transforms.search).to.exist;
      expect(clientConfig.transforms.search.facetsQuery).to.be.a('Function');
    });

    test('facetsQuery transform function given empty input does return default query', function() {
      var DEFAULT_FACETS_QUERY = {
        SPARQL: {
          'group-by': {
            limit: 0,
            offset: 0
          },
          'order-by': undefined,
          select: {
            variables: [],
          },
          where: {
            clauses: [],
            filters: [],
            type: 'Ad',
            variable: '?ad'
          }
        },
        type: 'Aggregation'
      };

      expect(clientConfig.transforms.search.facetsQuery()).to.deep.equal(DEFAULT_FACETS_QUERY);
      expect(clientConfig.transforms.search.facetsQuery({})).to.deep.equal(DEFAULT_FACETS_QUERY);
      expect(clientConfig.transforms.search.facetsQuery({}, {})).to.deep.equal(DEFAULT_FACETS_QUERY);
    });

    test('facetsQuery transform function given aggregation type does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'age'
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function does support all aggregation types', function() {
      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'age'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?age'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'city'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?city'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'country'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?country'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'email'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?email'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'ethnicity'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?ethnicity'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'eyeColor'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?eye_color'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'gender'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?gender'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'hairColor'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?hair_color'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'height'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?height'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'name'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?name'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'phone'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?phone'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'price'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?price'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'region'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?state'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'review'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?review_id'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'services'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?service'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'social'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?social_media_id'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'website'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?website'
      }]);

      expect(clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'weight'
      }).SPARQL.select.variables).to.deep.equal([{
        'function': 'count',
        type: 'function',
        variable: '?weight'
      }]);
    });

    test('facetsQuery transform function given page size does return correct query', function() {
      expect(clientConfig.transforms.search.facetsQuery({}, {
        pageSize: 10
      }).SPARQL['group-by']).to.deep.equal({
        limit: 10,
        offset: 0
      });
    });

    test('facetsQuery transform function given _term sort order does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({}, {
        aggregationType: 'age',
        sortOrder: '_term'
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': undefined,
          order: 'asc',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function given search parameters of same type does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          },
          titleB: {
            enabled: true,
            key: 'titleB'
          }
        }
      }, {
        aggregationType: 'age'
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        constraint: 'titleB',
        isOptional: true,
        predicate: 'title'
      }, {
        isOptional: true,
        predicate: 'title',
        variable: '?title1'
      }, {
        isOptional: true,
        predicate: 'title',
        variable: '?title2'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function given disabled search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        title: {
          titleA: {
            enabled: true,
            key: 'titleA'
          },
          titleB: {
            enabled: false,
            key: 'titleB'
          }
        }
      }, {
        aggregationType: 'age'
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        isOptional: true,
        predicate: 'title',
        variable: '?title1'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function given search parameter matching aggregation type does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        age: {
          ageA: {
            enabled: true,
            key: 'ageA'
          }
        }
      }, {
        aggregationType: 'age',
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'ageA',
        isOptional: true,
        predicate: 'age'
      }, {
        isOptional: true,
        predicate: 'age',
        variable: '?age1'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function given search parameters of multiple types does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        age: {
          ageA: {
            enabled: true,
            key: 'ageA'
          }
        },
        city: {
          cityA: {
            enabled: true,
            key: 'cityA'
          }
        },
        social: {
          socialA: {
            enabled: true,
            key: 'socialA'
          }
        }
      }, {
        aggregationType: 'age',
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'ageA',
        isOptional: true,
        predicate: 'age'
      }, {
        constraint: 'cityA',
        isOptional: true,
        predicate: 'city'
      }, {
        constraint: 'socialA',
        isOptional: true,
        predicate: 'social_media_id'
      }, {
        isOptional: true,
        predicate: 'age',
        variable: '?age1'
      }, {
        isOptional: true,
        predicate: 'city',
        variable: '?city1'
      }, {
        isOptional: true,
        predicate: 'social_media_id',
        variable: '?social_media_id1'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function given both optional and required search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        age: {
          ageA: {
            enabled: true,
            key: 'ageA',
            search: 'optional'
          },
          ageB: {
            enabled: true,
            key: 'ageB',
            search: 'required'
          }
        },
        city: {
          cityA: {
            enabled: true,
            key: 'cityA',
            search: 'required'
          },
          cityB: {
            enabled: true,
            key: 'cityB',
            search: 'optional'
          }
        }
      }, {
        aggregationType: 'age',
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'ageA',
        isOptional: true,
        predicate: 'age'
      }, {
        constraint: 'ageB',
        isOptional: false,
        predicate: 'age'
      }, {
        constraint: 'cityA',
        isOptional: false,
        predicate: 'city'
      }, {
        constraint: 'cityB',
        isOptional: true,
        predicate: 'city'
      }, {
        isOptional: true,
        predicate: 'age',
        variable: '?age1'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age2'
      }, {
        isOptional: false,
        predicate: 'city',
        variable: '?city1'
      }, {
        isOptional: true,
        predicate: 'city',
        variable: '?city2'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function given excluded search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        age: {
          ageA: {
            enabled: true,
            key: 'ageA',
            search: 'optional'
          },
          ageB: {
            enabled: true,
            key: 'ageB',
            search: 'excluded'
          }
        },
        city: {
          cityA: {
            enabled: true,
            key: 'cityA',
            search: 'excluded'
          },
          cityB: {
            enabled: true,
            key: 'cityB',
            search: 'optional'
          }
        }
      }, {
        aggregationType: 'age',
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        clauses: [{
          constraint: 'ageB',
          predicate: 'age'
        }, {
          constraint: 'cityA',
          predicate: 'city'
        }],
        operator: 'not exists'
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        constraint: 'ageA',
        isOptional: true,
        predicate: 'age'
      }, {
        constraint: 'cityB',
        isOptional: true,
        predicate: 'city'
      }, {
        isOptional: true,
        predicate: 'age',
        variable: '?age1'
      }, {
        isOptional: true,
        predicate: 'city',
        variable: '?city1'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function given union search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        age: {
          ageA: {
            enabled: true,
            key: 'ageA',
            search: 'union'
          }
        },
        city: {
          cityA: {
            enabled: true,
            key: 'cityA',
            search: 'union'
          },
          cityB: {
            enabled: true,
            key: 'cityB',
            search: 'union'
          },
          cityC: {
            enabled: true,
            key: 'cityC',
            search: 'excluded'
          }
        },
        title: {
          titleA: {
            enabled: true,
            key: 'titleA',
            search: 'optional'
          }
        }
      }, {
        aggregationType: 'age',
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        clauses: [{
          constraint: 'cityC',
          predicate: 'city'
        }],
        operator: 'not exists'
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        clauses: [{
          constraint: 'ageA',
          isOptional: false,
          predicate: 'age'
        }],
        operator: 'union'
      }, {
        clauses: [{
          constraint: 'cityA',
          isOptional: false,
          predicate: 'city'
        }, {
          constraint: 'cityB',
          isOptional: false,
          predicate: 'city'
        }],
        operator: 'union'
      }, {
        constraint: 'titleA',
        isOptional: true,
        predicate: 'title'
      }, {
        variable: '?title1',
        isOptional: true,
        predicate: 'title'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function with network expansion options types does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        age: {
          ageA: {
            enabled: true,
            key: 'ageA'
          }
        },
        city: {
          cityA: {
            enabled: true,
            key: 'cityA'
          }
        },
        social: {
          socialA: {
            enabled: true,
            key: 'socialA'
          }
        }
      }, {
        aggregationType: 'age',
        custom: {
          age: true
        }
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });

      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([]);
      expect(output.SPARQL.where.clauses).to.deep.equal([
        {
          clauses: [
            {
              constraint: 'ageA',
              isOptional: true,
              predicate: 'age'
            },
            {
              constraint: 'cityA',
              isOptional: true,
              predicate: 'city'
            },
            {
              constraint: 'socialA',
              isOptional: true,
              predicate: 'social_media_id'
            },
            {
              isOptional: false,
              predicate: 'age',
              variable: '?age'
            }
          ],
          type: 'Ad',
          variable: '?ad1'
        },
        {
          constraint: 'cityA',
          isOptional: true,
          predicate: 'city'
        },
        {
          constraint: 'socialA',
          isOptional: true,
          predicate: 'social_media_id'
        },
        {
          isOptional: false,
          predicate: 'age',
          variable: '?age'
        }
      ]);
    });

    test('facetsQuery transform function given date search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        postingDate: {
          dateStart: {
            enabled: true,
            date: 'start'
          },
          dateEnd: {
            enabled: true,
            date: 'end'
          }
        }
      }, {
        aggregationType: 'age'
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL['order-by']).to.deep.equal({
        values: [{
          'function': 'count',
          order: 'desc',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        operator: 'and',
        clauses: [{
          constraint: 'start',
          operator: '>=',
          variable: '?date1'
        }, {
          constraint: 'end',
          operator: '<=',
          variable: '?date1'
        }]
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        isOptional: false,
        predicate: 'posting_date',
        variable: '?date1'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('facetsQuery transform function given both enabled and disabled date search parameters does return correct query', function() {
      var output = clientConfig.transforms.search.facetsQuery({
        postingDate: {
          dateStart: {
            enabled: true,
            date: 'start'
          },
          dateEnd: {
            enabled: false,
            date: 'end'
          }
        }
      }, {
        aggregationType: 'age'
      });

      expect(output.type).to.equal('Aggregation');
      expect(output.SPARQL).to.be.an('Object');
      expect(output.SPARQL['group-by']).to.deep.equal({
        limit: 0,
        offset: 0,
        variables: [{
          variable: '?age'
        }]
      });
      expect(output.SPARQL.select).to.deep.equal({
        variables: [{
          'function': 'count',
          type: 'function',
          variable: '?age'
        }]
      });
      expect(output.SPARQL.where).to.be.an('Object');
      expect(output.SPARQL.where.variable).to.equal('?ad');
      expect(output.SPARQL.where.type).to.equal('Ad');
      expect(output.SPARQL.where.filters).to.deep.equal([{
        operator: 'and',
        clauses: [{
          constraint: 'start',
          operator: '>=',
          variable: '?date1'
        }]
      }]);
      expect(output.SPARQL.where.clauses).to.deep.equal([{
        isOptional: false,
        predicate: 'posting_date',
        variable: '?date1'
      }, {
        isOptional: false,
        predicate: 'age',
        variable: '?age'
      }]);
    });

    test('does define cityAggregations transform function', function() {
      assert.isObject(clientConfig.config);
      assert.isObject(clientConfig.transforms);
      assert.isObject(clientConfig.transforms.search);
      assert.isFunction(clientConfig.transforms.search.cityAggregations);
    });

    test('cityAggregations transform function does create a city list from the given response', function() {
      var cityAggregations = clientConfig.transforms.search.cityAggregations(cityResponse, {
        networkExpansionQuery: false,
        name: 'city'
      });
      assert.deepEqual(cityAggregations, [{
        count: 11,
        id: 'Ontario',
        link: '/location.html?id=Ontario:California:United States:-117.65089:34.06334',
        text: 'Ontario'
      }, {
        count: 10,
        id: 'Los Angeles',
        link: '/location.html?id=Los Angeles:California:United States:-118.24368:34.05223',
        text: 'Los Angeles'
      }, {
        count: 10,
        id: 'Mumbai',
        link: '/location.html?id=Mumbai:State of Maharashtra:India:72.88261:19.07283',
        text: 'Mumbai'
      }, {
        count: 9,
        id: 'Melbourne',
        link: '/location.html?id=Melbourne:Florida:United States:-80.60811:28.08363',
        text: 'Melbourne'
      }, {
        count: 8,
        id: 'Bakersfield',
        link: '/location.html?id=Bakersfield:California:United States:-119.01871:35.37329',
        text: 'Bakersfield'
      }, {
        count: 8,
        id: 'Dallas',
        link: '/location.html?id=Dallas:Texas:United States:-96.80667:32.78306',
        text: 'Dallas'
      }, {
        count: 8,
        id: 'Shanghai',
        link: '/location.html?id=Shanghai:Shanghai Shi:China:121.45806:31.22222',
        text: 'Shanghai'
      }, {
        count: 7,
        id: 'Miami',
        link: '/location.html?id=Miami:Florida:United States:-80.19366:25.77427',
        text: 'Miami'
      }, {
        count: 7,
        id: 'New York',
        link: '/location.html?id=New York:New York:United States:-74.00597:40.71427',
        text: 'New York'
      }, {
        count: 7,
        id: 'Oklahoma City',
        link: '/location.html?id=Oklahoma City:Oklahoma:United States:-97.51643:35.46756',
        text: 'Oklahoma City'
      }]);
    });

    test('cityAggregations transform function does create a city list from the given network expansion response', function() {
      var cityAggregations = clientConfig.transforms.search.cityAggregations(cityNetworkExpansionResponse, {
        networkExpansionQuery: true,
        name: 'city'
      });
      assert.deepEqual(cityAggregations, [{
        count: 11,
        id: 'Ontario',
        link: '/location.html?id=Ontario:California:United States:-117.65089:34.06334',
        text: 'Ontario'
      }, {
        count: 10,
        id: 'Los Angeles',
        link: '/location.html?id=Los Angeles:California:United States:-118.24368:34.05223',
        text: 'Los Angeles'
      }, {
        count: 10,
        id: 'Mumbai',
        link: '/location.html?id=Mumbai:State of Maharashtra:India:72.88261:19.07283',
        text: 'Mumbai'
      }, {
        count: 9,
        id: 'Melbourne',
        link: '/location.html?id=Melbourne:Florida:United States:-80.60811:28.08363',
        text: 'Melbourne'
      }, {
        count: 8,
        id: 'Bakersfield',
        link: '/location.html?id=Bakersfield:California:United States:-119.01871:35.37329',
        text: 'Bakersfield'
      }, {
        count: 8,
        id: 'Dallas',
        link: '/location.html?id=Dallas:Texas:United States:-96.80667:32.78306',
        text: 'Dallas'
      }, {
        count: 8,
        id: 'Shanghai',
        link: '/location.html?id=Shanghai:Shanghai Shi:China:121.45806:31.22222',
        text: 'Shanghai'
      }, {
        count: 7,
        id: 'Miami',
        link: '/location.html?id=Miami:Florida:United States:-80.19366:25.77427',
        text: 'Miami'
      }, {
        count: 7,
        id: 'New York',
        link: '/location.html?id=New York:New York:United States:-74.00597:40.71427',
        text: 'New York'
      }, {
        count: 7,
        id: 'Oklahoma City',
        link: '/location.html?id=Oklahoma City:Oklahoma:United States:-97.51643:35.46756',
        text: 'Oklahoma City'
      }]);
    });

    test('does define filterAggregations transform function', function() {
      assert.isObject(clientConfig.config);
      assert.isObject(clientConfig.transforms);
      assert.isObject(clientConfig.transforms.search);
      assert.isFunction(clientConfig.transforms.search.filterAggregations);
    });

    test('filterAggregations transform function does create a filter list from the given response', function() {
      var filterAggregations = clientConfig.transforms.search.filterAggregations(filterResponse, {
        networkExpansionQuery: false,
        name: 'property'
      });
      assert.deepEqual(filterAggregations, [{
        count: 20,
        id: '123'
      }, {
        count: 10,
        id: 'uppercase'
      }, {
        count: 5,
        id: 'lowercase'
      }]);
    });

    test('filterAggregations transform function does create a filter list from the given network expansion response', function() {
      var filterAggregations = clientConfig.transforms.search.filterAggregations(filterNetworkExpansionResponse, {
        networkExpansionQuery: true,
        name: 'property'
      });
      assert.deepEqual(filterAggregations, [{
        count: 20,
        id: '123'
      }, {
        count: 10,
        id: 'uppercase'
      }, {
        count: 5,
        id: 'lowercase'
      }]);
    });

    test('does define compoundExtractionAggregations transform function', function() {
      assert.isObject(clientConfig.config);
      assert.isObject(clientConfig.transforms);
      assert.isObject(clientConfig.transforms.search);
      assert.isFunction(clientConfig.transforms.search.compoundExtractionAggregations);
    });

    test('compoundExtractionAggregations transform function does create an extraction list from the given response', function() {
      var compoundExtractionAggregations = clientConfig.transforms.search.compoundExtractionAggregations(compoundResponse, {
        networkExpansionQuery: false,
        name: 'property'
      });
      assert.deepEqual(compoundExtractionAggregations, [{
        count: 80,
        id: '175',
        text: '175'
      }, {
        count: 40,
        id: '175',
        text: '175 cm'
      }, {
        count: 20,
        id: '175',
        text: '175 per 60 minutes'
      }, {
        count: 10,
        id: '175',
        text: '175 dollars'
      }, {
        count: 5,
        id: '175',
        text: '175 dollars per 60 minutes'
      }]);
    });

    test('does define emailAggregations transform function', function() {
      assert.isObject(clientConfig.config);
      assert.isObject(clientConfig.transforms);
      assert.isObject(clientConfig.transforms.search);
      assert.isFunction(clientConfig.transforms.search.emailAggregations);
    });

    test('compoundExtractionAggregations transform function does create an extraction list from the given network expansion response', function() {
      var compoundExtractionAggregations = clientConfig.transforms.search.compoundExtractionAggregations(compoundNetworkExpansionResponse, {
        networkExpansionQuery: true,
        name: 'property'
      });
      assert.deepEqual(compoundExtractionAggregations, [{
        count: 80,
        id: '175',
        text: '175'
      }, {
        count: 40,
        id: '175',
        text: '175 cm'
      }, {
        count: 20,
        id: '175',
        text: '175 per 60 minutes'
      }, {
        count: 10,
        id: '175',
        text: '175 dollars'
      }, {
        count: 5,
        id: '175',
        text: '175 dollars per 60 minutes'
      }]);
    });

    test('does define emailAggregations transform function', function() {
      assert.isObject(clientConfig.config);
      assert.isObject(clientConfig.transforms);
      assert.isObject(clientConfig.transforms.search);
      assert.isFunction(clientConfig.transforms.search.emailAggregations);
    });

    test('emailAggregations transform function does create an email list from the given response', function() {
      var emailAggregations = clientConfig.transforms.search.emailAggregations(emailResponse, {
        networkExpansionQuery: false,
        name: 'email'
      });
      assert.deepEqual(emailAggregations, [{
        count: 20,
        id: 'abc@gmail.com',
        link: '/email.html?id=abc%40gmail.com'
      }, {
        count: 10,
        id: 'xyz@gmail.com',
        link: '/email.html?id=xyz%40gmail.com'
      }, {
        count: 5,
        id: 'abc@yahoo.com',
        link: '/email.html?id=abc%40yahoo.com'
      }]);
    });

    test('does define phoneAggregations transform function', function() {
      assert.isObject(clientConfig.config);
      assert.isObject(clientConfig.transforms);
      assert.isObject(clientConfig.transforms.search);
      assert.isFunction(clientConfig.transforms.search.phoneAggregations);
    });

    test('emailAggregations transform function does create an email list from the given network expansion response', function() {
      var emailAggregations = clientConfig.transforms.search.emailAggregations(emailNetworkExpansionResponse, {
        networkExpansionQuery: true,
        name: 'email'
      });
      assert.deepEqual(emailAggregations, [{
        count: 20,
        id: 'abc@gmail.com',
        link: '/email.html?id=abc%40gmail.com'
      }, {
        count: 10,
        id: 'xyz@gmail.com',
        link: '/email.html?id=xyz%40gmail.com'
      }, {
        count: 5,
        id: 'abc@yahoo.com',
        link: '/email.html?id=abc%40yahoo.com'
      }]);
    });

    test('does define phoneAggregations transform function', function() {
      assert.isObject(clientConfig.config);
      assert.isObject(clientConfig.transforms);
      assert.isObject(clientConfig.transforms.search);
      assert.isFunction(clientConfig.transforms.search.phoneAggregations);
    });

    test('phoneAggregations transform function does create a phone list from the given response', function() {
      var phoneAggregations = clientConfig.transforms.search.phoneAggregations(phoneResponse, {
        networkExpansionQuery: false,
        name: 'phone'
      });
      assert.deepEqual(phoneAggregations, [{
        count: 80,
        id: '1234567890',
        link: '/phone.html?id=1234567890',
        text: '123-456-7890'
      }, {
        count: 40,
        id: '+1-1112223333',
        link: '/phone.html?id=+1-1112223333',
        text: '111-222-3333'
      }, {
        count: 20,
        id: '+2-4445556666',
        link: '/phone.html?id=+2-4445556666',
        text: '+2-444-555-6666'
      }, {
        count: 10,
        id: '+1234-7778889999',
        link: '/phone.html?id=+1234-7778889999',
        text: '+1234-777-888-9999'
      }, {
        count: 5,
        id: '+x-9876543210',
        link: '/phone.html?id=+x-9876543210',
        text: '987-654-3210'
      }]);
    });

    test('phoneAggregations transform function does create a phone list from the given network expansion response', function() {
      var phoneAggregations = clientConfig.transforms.search.phoneAggregations(phoneNetworkExpansionResponse, {
        networkExpansionQuery: true,
        name: 'phone'
      });
      assert.deepEqual(phoneAggregations, [{
        count: 80,
        id: '1234567890',
        link: '/phone.html?id=1234567890',
        text: '123-456-7890'
      }, {
        count: 40,
        id: '+1-1112223333',
        link: '/phone.html?id=+1-1112223333',
        text: '111-222-3333'
      }, {
        count: 20,
        id: '+2-4445556666',
        link: '/phone.html?id=+2-4445556666',
        text: '+2-444-555-6666'
      }, {
        count: 10,
        id: '+1234-7778889999',
        link: '/phone.html?id=+1234-7778889999',
        text: '+1234-777-888-9999'
      }, {
        count: 5,
        id: '+x-9876543210',
        link: '/phone.html?id=+x-9876543210',
        text: '987-654-3210'
      }]);
    });

    test('does define socialMediaAggregations transform function', function() {
      assert.isObject(clientConfig.config);
      assert.isObject(clientConfig.transforms);
      assert.isObject(clientConfig.transforms.search);
      assert.isFunction(clientConfig.transforms.search.socialMediaAggregations);
    });

    test('socialMediaAggregations transform function does create a social media list from the given response', function() {
      var socialMediaAggregations = clientConfig.transforms.search.socialMediaAggregations(socialMediaResponse, {
        networkExpansionQuery: false,
        name: 'social'
      });

      assert.deepEqual(socialMediaAggregations, [{
        count: 80,
        id: 'user123',
        link: '/social.html?id=twitter%20user123',
        text: 'twitter user123'
      }, {
        count: 40,
        id: 'user456',
        link: '/social.html?id=twitter%20user456',
        text: 'twitter user456'
      }, {
        count: 20,
        id: 'user789',
        link: '/social.html?id=twitter%20user789',
        text: 'twitter user789'
      }, {
        count: 10,
        id: 'userabc',
        link: '/social.html?id=instagram%20userABC',
        text: 'instagram userabc'
      }, {
        count: 5,
        id: 'userxyz',
        link: '/social.html?id=userXYZ',
        text: 'userxyz'
      }]);
    });

    test('socialMediaAggregations transform function does create a social media list from the given network expansion response', function() {
      var socialMediaAggregations = clientConfig.transforms.search.socialMediaAggregations(socialMediaNetworkExpansionResponse, {
        networkExpansionQuery: true,
        name: 'social'
      });

      assert.deepEqual(socialMediaAggregations, [{
        count: 80,
        id: 'user123',
        link: '/social.html?id=twitter%20user123',
        text: 'twitter user123'
      }, {
        count: 40,
        id: 'user456',
        link: '/social.html?id=twitter%20user456',
        text: 'twitter user456'
      }, {
        count: 20,
        id: 'user789',
        link: '/social.html?id=twitter%20user789',
        text: 'twitter user789'
      }, {
        count: 10,
        id: 'userabc',
        link: '/social.html?id=instagram%20userABC',
        text: 'instagram userabc'
      }, {
        count: 5,
        id: 'userxyz',
        link: '/social.html?id=userXYZ',
        text: 'userxyz'
      }]);
    });
  });
</script>
</body>
</html>
