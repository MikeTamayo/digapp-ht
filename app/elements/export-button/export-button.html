<!--
Copyright 2017 Next Century Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/build-and-run-query/build-and-run-query.html">
<link rel="import" href="../../bower_components/elastic-client-query-builder/elastic-client-query-builder.html">
<link rel="import" href="../../bower_components/json-transform/json-transform.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../bower_components/paper-radio-button/paper-radio-button.html">
<link rel="import" href="../../bower_components/paper-radio-group/paper-radio-group.html">
<link rel="import" href="../pdfmake.html">

<dom-module id="export-button">
  <template>
    <style include="iron-flex"></style>
    <style>
      :host {
        display: block;
      }

      styled-dialog ::content .fill .inside {
        min-height: 500px;
        min-width: 700px;
      }

      .link {
        color: var(--secondary-text-color);
        cursor: pointer;
        font-weight: 500;
        text-decoration: underline;
      }

      .link:hover {
        color: var(--primary-text-color);
      }

      .link > iron-icon {
        margin-top: 2px;
      }

      .link > .open {
        line-height: 30px;
        margin-left: 5px;
      }

      .disabled {
        cursor: default;
        opacity: 0.5;
        pointer-events: none;
        text-decoration: none;
      }

      .hide {
        visibility: hidden;
      }
    </style>

    <template is="dom-if" if="[[data.length]]">
      <div class="layout horizontal center link" on-tap="open">
        <iron-icon icon="file-download"></iron-icon>
        <span class="open">Export</span>
      </div>
    </template>

    <styled-dialog id="dialog" header="Export" fill>
      <div class="styled-dialog-text">Name of Export File:</div>
      <paper-input label="Enter Export Filename" value="{{filename}}" no-label-float></paper-input>

      <div class="styled-dialog-text">Number to Export:</div>

      <paper-radio-group class="layout vertical" selected="{{_selectedMode}}">
        <paper-radio-button name="input">The [[data.length]] Ads Currently Shown (PDF or CSV)</paper-radio-button>
        <paper-radio-button disabled="[[_isBulkExportDisabled(data.length, size)]]" name="query">The Top 10,000 Ads Matching Each Keyword (CSV Only)</paper-radio-button>
      </paper-radio-group>

      <div class="layout horizontal styled-dialog-text">
        <template is="dom-if" if="[[_isBulk(_selectedMode)]]">
          <span class="link styled-dialog-right-space disabled">Export to PDF</span>

          <span class="styled-dialog-right-space">|</span>

          <template is="dom-if" if="[[!_isBulkDataDoneLoading(_keywordArray, _keywordIndex)]]">
            <span class="link" on-tap="_runBulkDataQueries">Load Data</span>
          </template>
          <template is="dom-if" if="[[_isBulkDataDoneLoading(_keywordArray, _keywordIndex)]]">
            <span class="link" on-tap="_exportBulkDataForCsv">Export to CSV</span>
          </template>
        </template>

        <template is="dom-if" if="[[!_isBulk(_selectedMode)]]">
          <span class="link styled-dialog-right-space" on-tap="_exportDataForPdf">Export to PDF</span>

          <span class="styled-dialog-right-space">|</span>

          <a is="csv-download" class="link" data="[[_dataForCsv]]" download="[[filename]].csv">Export to CSV</a>
        </template>
      </div>

      <template is="dom-if" if="[[!_isBulk(_selectedMode)]]">
        <div class="note">Please note that it may take a minute or longer to export hundreds of results to PDF.</div>
      </template>

      <template is="dom-if" if="[[_isBulk(_selectedMode)]]">
        <div class="note">If your file doesn't download automatically, please check that your internet browser allows popups from this page.</div>
        <div class="note">Please note that it may take a minute or longer to load tens of thousands of results returned from many keywords.</div>
      </template>

      <template is="dom-if" if="[[_isBulk(_selectedMode)]]">
        <template is="dom-if" if="[[_isBulkDataLoadingOrDone(_queryReady, _keywordArray, _keywordIndex)]]">
          <template is="dom-repeat" items="[[_keywordArray]]">
            <template is="dom-if" if="[[_isNotUndefined(item.count)]]">
              <div class="note">Loaded Top <span>[[item.count]]</span> Ads Matching Keyword <span>[[item.value]]</span></div>
            </template>
            <template is="dom-if" if="[[!_isNotUndefined(item.count)]]">
              <div class="note">Loading Top Ads Matching Keyword <span>[[item.value]]</span>...</div>
            </template>
          </template>
        </template>
      </template>

      <template is="dom-if" if="[[_bulkDataFileExportError]]">
        <div>Error Exporting CSV File</div>
      </template>

      <template is="dom-if" if="[[_queryLoading]]">
        <loading-spinner show="[[_queryLoading]]" type="Data"></loading-spinner>
      </template>

      <template is="dom-if" if="[[_bulkDataFileExportLoading]]">
        <loading-spinner show="[[_bulkDataFileExportLoading]]" type="File"></loading-spinner>
      </template>

      <template is="dom-if" if="[[loading]]">
        <loading-spinner show="[[loading]]" type="File"></loading-spinner>
      </template>
    </styled-dialog>

    <elastic-client-query-builder
      type="terms"
      fields='["_all"]'
      values="[[_getKeyword(_keywordArray, _keywordIndex)]]"
      ejs-query="{{_query}}">
    </elastic-client-query-builder>

    <elastic-client-search
      client="[[client]]"
      index="[[indexName]]"
      page="1"
      page-size="10000"
      elastic-types="[[indexTypes]]"
      query="[[_query]]"
      aggregations="[]"
      filters="[[filterList]]"
      sort="[[sort]]"
      sort-field="[[sortField]]"
      sort-order="[[sortOrder]]"
      results="{{_queryResults}}"
      loading="{{_queryLoading}}"
      last-error="{{_queryError}}"
      properties-ready="{{_queryReady}}">
    </elastic-client-search>

    <json-transform
      data-in="[[_queryResults]]"
      data-out="{{_bulkDataSubset}}"
      transform-function="[[queryTransformFunction]]">
    </json-transform>

    <json-transform
      data-in="[[_bulkDataSubset]]"
      data-out="{{_bulkDataSubsetForCsv}}"
      transform-function="[[csvTransformFunction]]">
    </json-transform>

    <iron-ajax id="bulkExport"
      body="[[_bulkDataForCsv]]"
      content-type="application/json"
      handle-as="text"
      method="POST"
      url="/export"
      on-response="_openBulkDataFile"
      last-error="{{_bulkDataFileExportError}}"
      last-response="{{_bulkDataFileExportResponse}}"
      loading="{{_bulkDataFileExportLoading}}">
    </iron-ajax>

    <div>
      <template is="dom-repeat" items="[[_dataForPdf]]">
        <template is="dom-repeat" items="[[item.images]]" as="image">
          <img id$="[[image.id]]" crossorigin="anonymous" src="[[_getImageSrc(downloadImageUrl, image.source)]]" style="display:none"/>
        </template>
      </template>
    </div>
  </template>

  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'export-button',

      /* globals pdfMake */
      properties: {
        /**
         * The elasticsearch client to load bulk export data.
         */
        client: {
          type: Object
        },

        /**
         * The function to transform the data into CSV export data.
         */
        csvTransformFunction: {
          type: Function
        },

        /**
         * The data to transform and export.
         */
        data: {
          type: Array
        },

        /**
         * The URL needed by the PDF export to download each image.
         */
        downloadImageUrl: {
          type: String
        },

        /**
         * The name of the exported file.
         */
        filename: {
          type: String,
          value: 'data'
        },

        /**
         * The bulk data query filters.
         */
        filterList: {
          type: Array
        },

        /**
         * The elasticsearch index name to load bulk export data.
         */
        indexName: {
          type: String
        },

        /**
         * The elasticsearch index types to load bulk export data.
         */
        indexTypes: {
          type: Array
        },

        /**
         * The searchParameters object used for the bulk data query.
         */
        searchParameters: {
          type: Object
        },

        /**
         * Whether the export file is loading.
         */
        loading: {
          notify: true,
          type: Boolean,
          value: false
        },

        /**
         * The function to transform the data into PDF export data.
         */
        pdfTransformFunction: {
          type: Function
        },

        /**
         * The function to transform the bulk query elasticsearch results into data.
         */
        queryTransformFunction: {
          type: Function
        },

        /**
         * The size of all the data (not the input data).
         */
        size: {
          type: Number
        },

        /**
         * The elasticsearch sort to load bulk export data.
         */
        sort: {
          type: Object
        },

        /**
         * The elasticsearch sort field to load bulk export data.
         */
        sortField: {
          type: String
        },

        /**
         * The elasticsearch sort order to load bulk export data.
         */
        sortOrder: {
          type: String
        },

        /**
         * The bulk data file export error.
         */
        _bulkDataFileExportError: {
          type: Object
        },

        /**
         * Whether the bulk data file export is loading.
         */
        _bulkDataFileExportLoading: {
          type: Object
        },

        /**
         * The bulk data file export response.
         */
        _bulkDataFileExportResponse: {
          type: Object
        },

        /**
         * The CSV export data for the bulk data (from all the query results).
         */
        _bulkDataForCsv: {
          type: Array,
          value: []
        },

        /**
         * The bulk data from one set of elasticsearch query results (one keyword).
         */
        _bulkDataSubset: {
          type: Array,
          value: []
        },

        /**
         * The CSV export data for the bulk data subset (from one set of query results).
         */
        _bulkDataSubsetForCsv: {
          type: Array,
          value: []
        },

        /**
         * The CSV export data for the data (from the element input) for the csv-download component.
         */
        _dataForCsv: {
          type: Array
        },

        /**
         * The PDF export data for the data (from the element input) for the pdfMake library.
         */
        _dataForPdf: {
          type: Array
        },

        /**
         * The array of query keywords.
         */
        _keywordArray: {
          type: Array
        },

        /**
         * The current query index in the array of query keywords.
         */
        _keywordIndex: {
          type: Number,
          value: 0
        },

        /**
         * The elasticsearch bulk data query.
         */
        _query: {
          type: Object
        },

        /**
         * The elasticsearch bulk data error.
         */
        _queryError: {
          type: Object
        },

        /**
         * Whether the elasticsearch bulk data query is running.
         */
        _queryLoading: {
          type: Boolean,
          value: false
        },

        /**
         * Whether to run the elasticsearch bulk data query.
         */
        _queryReady: {
          type: Boolean,
          value: false
        },

        /**
         * The elasticsearch bulk data query results.
         */
        _queryResults: {
          type: Object
        },

        /**
         * The selected mode string (query or input).
         */
        _selectedMode: {
          type: String,
          value: 'input'
        }
      },

      observers: [
        // Use observers rather than a json-transform element because we must observe changes on data.* rather than data itself.
        '_computeDataForCsv(data.length, csvTransformFunction)',
        '_computeDataForPdf(data.*, pdfTransformFunction)',
        '_computeDataForCsv(data.length, csvTransformFunction)',
        '_computeDataForPdf(data.*, pdfTransformFunction)',
        '_resetBulkDataResults(filterList)',
        '_resetBulkDataResults(filterList.*)',
        '_resetBulkDataResults(searchParameters.*)',
        '_updateBulkDataFilename(filename)',
        '_updateBulkDataFromSubset(_bulkDataSubsetForCsv)',
        '_updateKeywordArray(searchParameters.*)'
      ],

      /**
       * Computes the CSV export data using the input data and the transform function.
       */
      _computeDataForCsv: function() {
        this._dataForCsv = this.csvTransformFunction(this.data);
      },

      /**
       * Computes the PDF export data using the input data and the transform function.
       */
      _computeDataForPdf: function() {
        this._dataForPdf = this.pdfTransformFunction(this.data);
      },

      /**
       * Creates and returns the pdfMake PDF content for the given data.
       */
      _createPdfContent: function(data) {
        var doc = {
          content: []
        };

        var self = this;

        data.forEach(function(item, index) {
          if(index) {
            doc.content.push({
              pageBreak: 'after',
              text: ''
            });
          }

          item.paragraphs.forEach(function(object) {
            doc.content.push({
              fontSize: object.big ? 16 : 12,
              margin: [0, 0, 0, 10],
              text: [{
                bold: true,
                text: object.label
              }, {
                text: object.value
              }]
            });
          });

          doc.content.push({
            bold: true,
            fontSize: 12,
            margin: [0, 0, 0, 10],
            text: 'Image(s):'
          });

          item.images.forEach(function(image) {
            doc.content.push({
              fontSize: 12,
              margin: [0, 0, 0, 10],
              text: image.text
            });

            var imageElement = self.$$('#' + image.id);
            var canvas = document.createElement('canvas');
            canvas.width = imageElement.width;
            canvas.height = imageElement.height;
            canvas.getContext('2d').drawImage(imageElement, 0, 0);
            var source = canvas.toDataURL('image/jpeg');
            if(source.indexOf('data:image') === 0) {
              doc.content.push({
                fit: [500, 250],
                image: source,
                margin: [0, 0, 0, 10]
              });
            }
          });
        });

        return doc;
      },

      /**
       * Export the bulk data for CSV using an AJAX call.
       */
      _exportBulkDataForCsv: function() {
        this.$$('#bulkExport').generateRequest();
      },

      /**
       * Creates a PDF using the export data and downloads it automatically with pdfMake.
       */
      _exportDataForPdf: function() {
        this.set('loading', true);
        var doc = this._createPdfContent(this._dataForPdf);
        var self = this;
        setTimeout(function() {
          pdfMake.createPdf(doc).download(self.filename + '.pdf');
          self.set('loading', false);
        }, 500);
      },

      /**
       * Returns the image source needed by the PDF export to download each image.
       */
      _getImageSrc: function(url, source) {
        return '/' + url + '/' + source;
      },

      /**
       * Returns the keyword in the given array at the given index.
       */
      _getKeyword: function(array, index) {
        return index < array.length ? array[index].value : undefined;
      },

      /**
       * Returns whether the two inputs are equal.
       */
      _isBulk: function(mode) {
        return mode === 'query';
      },

      /**
       * Returns whether the bulk data is done loading using the given keyword array and index.
       */
      _isBulkDataDoneLoading: function(array, index) {
        return array && (index === array.length);
      },

      /**
       * Returns whether the bulk data is loading or done using the given run status and keyword array and index.
       */
      _isBulkDataLoadingOrDone: function(run, array, index) {
        return run || this._isBulkDataDoneLoading(array, index);
      },

      /**
       * Returns whether bulk export is disabled.
       */
      _isBulkExportDisabled: function() {
        return this.data.length >= this.size;
      },

      /**
       * Returns whether the given argument is undefined.
       */
      _isNotUndefined: function(argument) {
        return typeof argument !== 'undefined';
      },

      /**
       * Automatically downloads the file from the bulk data export response by opening it in a new window.
       */
      _openBulkDataFile: function() {
        if(this._bulkDataFileExportResponse) {
          window.open(this._bulkDataFileExportResponse, 'export');
        }
      },

      /**
       * Resets the bulk data for a new elasticsearch query.
       */
      _resetBulkDataResults: function() {
        this.set('_bulkDataForCsv', []);
        this.set('_keywordIndex', 0);
        this.set('_selectedMode', 'input');
        if(this._keywordArray) {
          var self = this;
          this._keywordArray.forEach(function(value, index) {
            self.set('_keywordArray.' + index + '.count', null);
          });
        }
      },

      /**
       * Runs the elasticsearch query.
       */
      _runBulkDataQueries: function() {
        this.set('_queryReady', true);
      },

      /**
       * Updates the bulk data filename using the given filename.
       */
      _updateBulkDataFilename: function(filename) {
        if(this._bulkDataForCsv && this._bulkDataForCsv.length) {
          this._bulkDataForCsv[0] = filename;
        }
      },

      /**
       * Updates the bulk data from the given data subset and then runs either the next bulk data query or the bulk data export call.
       */
      _updateBulkDataFromSubset: function(data) {
        // If the queryResults are null/undefined then the query hasn't finished running yet!
        if(!this._keywordArray || !this._queryResults) {
          return;
        }

        if(this._keywordIndex === 0) {
          // The first two array elements are the filename and the CSV header.
          this.set('_bulkDataForCsv', [this.filename].concat(data.slice(0, 1)));
        }

        // Slice to remove the CSV header from the list.
        this.set('_bulkDataForCsv', this._bulkDataForCsv.concat(data.slice(1)));

        // Set the count shown in the dialog.
        this.set('_keywordArray.' + this._keywordIndex + '.count', data.length - 1);

        // Start a new query.
        this.set('_keywordIndex', this._keywordIndex + 1);

        if(this._isBulkDataDoneLoading(this._keywordArray, this._keywordIndex)) {
          // No more runs needed.
          this.set('_queryReady', false);
          this._exportBulkDataForCsv();
        }
      },

      /**
       * Updates the keyword array and index using the given searchParameter object.
       */
      _updateKeywordArray: function(searchParameters) {
        if(searchParameters) {
          var keywords = [];
          this.set('_keywordIndex', 0);

          //get the object containing all search field objects
          var searchParameter = searchParameters.base;

          //find all non empty searchFields
          for(var searchField in searchParameter) {
            var search = searchParameter[searchField];

            if(!_.isEmpty(search)) {
              var keys = Object.keys(search);

              //update the keyword array
              for(var i = 0; i < keys.length; i++) {
                var element = search[keys[i]];
  
                if(element.enabled) {
                  var obj = {
                    value: element.key
                  };
                  keywords.push(obj);
                }
              }
            }
          }
          this.set('_keywordArray', keywords);
        }
      },

      /**
       * Opens the export dialog.
       */
      open: function() {
        this.$$('#dialog').open();
      }
    });
  })();
  </script>
</dom-module>
