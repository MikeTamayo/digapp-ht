<!--
Copyright 2017 Next Century Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/build-and-run-query/build-and-run-query.html">
<link rel="import" href="../../bower_components/elastic-create/elastic-create.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../bower_components/moment-element/moment-with-locales-import.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/styled-dialog/styled-dialog.html">
<link rel="import" href="../search-info-display/search-info-display.html">
<link rel="import" href="../behaviors.html">
<link rel="import" href="../clipboard.html">
<link rel="import" href="../lodash.html">
<link rel="import" href="../uuid.html">

<dom-module id="state-manager">
  <template>
    <style include="iron-flex"></style>
    <style>
      :host {
        display: block;
      }

      .terms {
        margin-left: 10px;
      }

      .nowrap {
        flex-wrap: nowrap;
      }
    </style>
    <build-and-run-query
      raw
      fields='"id"'
      values="[[stateId]]"
      client="[[client]]"
      index-name="[[stateIndex]]"
      index-types="[]"
      aggregations="[]"
      filters="[]"
      results="{{_stateIdResults}}">
    </build-and-run-query>

    <elastic-create
      client="[[client]]"
      index="[[stateIndex]]"
      elastic-type="[[stateType]]"
      body="[[_creationBody]]"
      results="{{_creationResults}}">
    </elastic-create>

    <build-and-run-query
      raw
      fields='"state"'
      values="[[_stringifiedState]]"
      client="[[client]]"
      index-name="[[stateIndex]]"
      index-types="[]"
      aggregations="[]"
      filters="[]"
      results="{{_stringifiedStateResults}}">
    </build-and-run-query>

    <styled-dialog id="linkDialog" header="Page Link" on-opened-changed="_toggleClipboard">
      <div class="layout horizontal">
        <div id="link" class="styled-dialog-right-space styled-dialog-tall flex">[[_link]]</div>
        <paper-icon-button id="copyToClipboard" icon="content-copy" title="Copy Link to Clipboard" data-clipboard-target="#link"></paper-icon-button>
      </div>
    </styled-dialog>

    <styled-dialog id="searchHistoryDialog" header="View Search History">
      <template is="dom-repeat" items="[[searchHistory]]">
        <div class="layout horizontal">
          <div class="styled-dialog-name styled-dialog-tall styled-dialog-right-space">Searched At</div>
          <div class="styled-dialog-text styled-dialog-tall styled-dialog-right-space nowrap">[[item.time]]</div>
          <search-info-display class="flex-1 terms" search-parameters="[[item.searchParameters]]"></search-info-display>
          <paper-icon-button class="self-end" icon="search" title="Run Search" on-tap="_runSearch"></paper-icon-button>
        </div>
      </template>
    </styled-dialog>
  </template>

  <script>
  (function() {
    'use strict';

    /* globals _, moment, Clipboard, DigBehaviors, uuid */
    Polymer({
      is: 'state-manager',

      behaviors: [
        DigBehaviors.BrowserBehavior,
        DigBehaviors.FilterBehavior,
        DigBehaviors.StateBehavior
      ],

      properties: {
        /**
         * The elasticsearch client.
         *
         * @type {Object}
         */
        client: {
          type: Object
        },

        /**
         * The object with properties for lists of strings to filter.
         *
         * @type {Object}
         */
        filterCollection: {
          type: Object,
          notify: true
        },

        /**
         * The format to use for the dates stored in searchHistory.
         *
         * @type {String}
         * @default 'hh:mm:ss A'
         */
        format: {
          type: String,
          value: 'hh:mm:ss A'
        },

        /**
         * The object with properties for lists of strings to filter.
         *
         * @type {Object}
         */
        hasHistory: {
          type: Boolean,
          notify: true
        },

        /**
         * Tracking the search history.
         *
         * @type {Array}
         */
        searchHistory: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /**
         * The ID for the state.
         *
         * @type {String}
         */
        stateId: {
          type: String
        },

        /**
         * The name of the state elasticsearch index.
         *
         * @type {String}
         */
        stateIndex: {
          type: String
        },

        /**
         * The name of the state elasticsearch type.
         *
         * @type {String}
         */
        stateType: {
          type: String
        },

        /**
         * Whether this component is used on the search or entity page.
         *
         * @type {String}
         * @default 'entity'
         */
        pageType: {
          type: String,
          value: 'entity'
        },

        /**
         * Whether or not all properties have been loaded/are ready for elastic-client-search.
         *
         * @type {Boolean}
         */
        processRequest: {
          type: Boolean,
          notify: true
        },

        /**
         * The request body for creation of new states.
         *
         * @type {Object}
         * @private
         */
        _creationBody: {
          type: Object
        },

        /**
         * The results from the requests for creation of new states.
         *
         * @type {Object}
         * @private
         */
        _creationResults: {
          type: Object
        },

        /**
         * The results from the state ID query.
         *
         * @type {Object}
         * @private
         */
        _stateIdResults: {
          type: Object,
          observer: '_handleStateIdResults'
        },

        /**
         * The stringified state for the stringified state query.
         *
         * @type {String}
         * @private
         */
        _stringifiedState: {
          type: String
        },

        /**
         * The results from the stringified string query.
         *
         * @type {Object}
         * @private
         */
        _stringifiedStateResults: {
          type: Object,
          observer: '_updateOrCreateId'
        },

        /**
         * The page link shown in the dialog.
         *
         * @type {String}
         * @private
         */
        _link: {
          type: String
        },

        /**
         * Whether the state ID query was run to validate the uniqueness of the ID (rather than getting the state for that ID).
         *
         * @type {Boolean}
         * @default false
         * @private
         */
        _validateId: {
          type: Boolean,
          value: false
        },

        /**
         * The clipboard object used to copy link text from the browser to the clipboard.
         *
         * @type {Object}
         * @private
         */
        _clipboard: {
          type: Object
        },

        /**
         * Temporary -- we still need to display the link popup on entity views since we're only
         * working on search history on the main search page right now.
         */
        showLinkDialog: {
          type: Boolean,
          notify: true,
          value: true
        }
      },

      observers: [
        '_addToHistory(filterCollection.*, processRequest, showLinkDialog)',
        '_checkHistory(searchHistory.*)'
      ],

      /**
       * Opens the search history dialog.
       */
      openSearchHistory: function() {
        this.$$('#searchHistoryDialog').open();
      },

      /**
       * Generate a link for the state by getting an existing, matching ID or creating a new one.
       */
      generateLink: function() {
        var state = this._createStringifiedState(this.filterCollection, this.pageType);
        if(this._isEmptyState(JSON.parse(state))) {
          this._updateUrlAndShowDialog();
        } else if(state === this._stringifiedState && this.showLinkDialog) {
          this.$$('#linkDialog').open();
        } else {
          this._stringifiedState = state;
        }
      },

      /**
       * Runs a search from the searchHistory list using state id link.
       * When run, that history item is moved to be the first item in the list and dialog is closed.
       *
       * @param {Object} event
       * @private
       */
      _runSearch: function(event) {
        this.splice('searchHistory', event.model.index, 1);
        this._unshiftSearchHistoryItem(event.model.item.searchParameters, event.model.item.id);
        this.set('filterCollection', this._copyFilterCollection(event.model.item.searchParameters));
        history.pushState({state: event.model.item.id, searchHistory: this.searchHistory}, '', '?state=' + event.model.item.id);
        this.$$('#searchHistoryDialog').close();
      },

      /**
       * Returns a copy of filterCollection object passed in.
       *
       * @param {Object} filterCollection
       * @return {Object} copy
       * @private
       */
      _copyFilterCollection: function(filterCollection) {
        return JSON.parse(JSON.stringify(filterCollection));
      },

      /**
       * Place a new search history item at the beginning of the searchHistory list.
       *
       * @param {Object} searchParameters
       * @param {String} stateId
       * @private
       */
      _unshiftSearchHistoryItem: function(searchParameters, stateId) {
        this.unshift('searchHistory', {
          searchParameters: this._copyFilterCollection(searchParameters),
          id: stateId,
          time: moment(new Date()).format(this.format)
        });
      },

      /**
       * Recalculates value of hasHistory based on current state of searchHistory array.
       *
       * @private
       */
      _checkHistory: function() {
        this.hasHistory = this.searchHistory && this.searchHistory.length > 0;
      },

      /**
       * If there are filters selected, generate a state id and add history item to searchHistory.
       *
       * @private
       */
      _addToHistory: function() {
        if(this.showLinkDialog || !this.processRequest || this.areAllFacetsDisabled(this.filterCollection, ['sort'])) {
          return;
        }

        this.generateLink();
      },

      _toggleClipboard: function(opened) {
        if(opened) {
          this._clipboard = new Clipboard('#copyToClipboard');
        } else if(this._clipboard) {
          // Destroy the clipboard object whenever the dialog is closed in order to avoid console errors.
          this._clipboard.destroy();
        }
      },

      /**
       * Creates and returns the stringified state for the given filter collection object.
       */
      _createStringifiedState: function(filterCollection, pageType) {
        if(pageType === 'entity') {
          // From DigBehaviors.StateBehavior
          return JSON.stringify(this.buildEntityState(filterCollection));
        }
        if(pageType === 'search') {
          // From DigBehaviors.StateBehavior
          return JSON.stringify(this.buildSearchState(filterCollection));
        }
        return JSON.stringify({});
      },

      /**
       * Creates and returns a new unique ID.
       */
      _generateId: function() {
        return uuid.v4();
      },

      /**
       * Handles the results from the state ID query:  either creating a new state or the updating the filters using the results.
       */
      _handleStateIdResults: function() {
        if(this._stateIdResults) {
          if(this._stateIdResults.hits.hits.length) {
            // If the query was triggered to validate a new ID and that ID is already in use, generate a new ID to trigger another query.
            if(this._validateId) {
              this.stateId = this._generateId();
            } else {
              this._updateFilterCollection(this._stateIdResults.hits.hits[0]._source.state, this.pageType);
            }
          } else if(this._validateId) {
            this._validateId = false;
            this._populateCreationBody(this.stateId, this.filterCollection, this.pageType);
          }
        }
      },

      /**
       * Returns whether the keys in the given state object are all empty.
       */
      _isEmptyState: function(state) {
        var empty = true;
        _.keys(state).forEach(function(key) {
          empty = empty && _.isEmpty(state[key]);
        });
        return empty;
      },

      /**
       * Sets the body of the state creation request using the given state ID and collection object, updates the browser URL, and shows the dialog with the page link.
       */
      _populateCreationBody: function(stateId, filterCollection, pageType) {
        this._creationBody = {
          id: stateId,
          state: this._createStringifiedState(filterCollection, pageType)
        };
        this._updateUrlAndShowDialog(stateId);
      },

      /**
       * Sets the filter collection to a new object using the given stringified state.
       */
      _updateFilterCollection: function(stringifiedState, pageType) {
        var state = JSON.parse(stringifiedState);
        this.set('processRequest', false);
        if(pageType === 'entity') {
          // From DigBehaviors.StateBehavior
          this.set('filterCollection', this.buildEntityState(state));
        }
        if(pageType === 'search') {
          // From DigBehaviors.StateBehavior
          this.set('filterCollection', this.buildSearchState(state));
        }
        this.set('processRequest', true);
      },

      /**
       * Updates the state ID using the results from the state ID query or creates a new ID if needed.
       */
      _updateOrCreateId: function() {
        if(this._stringifiedStateResults) {
          if(this._stringifiedStateResults.hits.hits.length) {
            // Do not set this.stateId here because that will trigger another query.
            var stateId = this._stringifiedStateResults.hits.hits[0]._source.id;
            this._updateUrlAndShowDialog(stateId);
          } else {
            this._validateId = true;
            this.stateId = this._generateId();
          }
        }
      },

      /**
       * Updates the browser URL with the state ID and shows the dialog with the page link (including the state ID).
       * Adds item to history if applicable.
       */
      _updateUrlAndShowDialog: function(id) {
        // From DigBehaviors.BrowserBehavior
        this._link = this.generateLinkWithStateParameter(window.location, id);
        var params = DigBehaviors.BrowserBehavior.getUrlParameters(window.location.search);

        if(params.state && params.state === id) {
          return;
        }

        if(this.showLinkDialog) {
          this.$$('#linkDialog').open();
        } else {
          // make sure this searchHistory item is the latest entry in searchHistory
          if(this.searchHistory.length === 0 || (this.searchHistory.length > 0 &&
            JSON.stringify(this.filterCollection) !== JSON.stringify(this.searchHistory[0].searchParameters))) {
            this._unshiftSearchHistoryItem(this.filterCollection, id);
          }
          // update URL with stateId
          history.pushState({state: id, searchHistory: this.searchHistory}, '', '?state=' + id);
        }
      }
    });
  })();
  </script>
</dom-module>
