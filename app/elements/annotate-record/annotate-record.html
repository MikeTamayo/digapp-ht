<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/elastic-create/elastic-create.html">
<link rel="import" href="../../bower_components/elastic-search/elastic-search.html">
<link rel="import" href="../../bower_components/elastic-update/elastic-update.html">
<link rel="import" href="../../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-item/paper-icon-item.html">
<link rel="import" href="../../bower_components/paper-item/paper-item-body.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">

<dom-module id="annotate-record">
  <template>
    <style>
      :host {
        display: block;
        margin-left: 10px;
      }
      .annotation-icon {
        color: var(--grey);
      }
      .annotation-icon[disabled] {
        color: var(--disabled-text-color);
        opacity: var(--dark-disabled-opacity);
      }
      .positive {
        color: var(--blue);
      }
      .negative {
        color: var(--red);
      }
      .dropdown-content {
        background-color: #fff;
        border: 1px solid var(--dark-primary-color);
        border-radius: 3px;
        padding: 10px;
      }
      .annotation-option {
        font-size: 14px;
        --paper-item-icon-width: 24px;
        --paper-item-min-height: 40px;
        --paper-item-focused-before: {
          background: initial;
        }
      }
      .annotation-option:hover {
        background-color: rgba(0,0,0,0.1);
      }
      .annotation-option.selected {
        background-color: var(--accent-color);
      }
      .dropdown-button {
        @apply(--shadow-elevation-4dp);
        margin: 5px 0 5px 10px;
      }
      .dropdown-button:hover {
        @apply(--shadow-elevation-8dp);
      }
    </style>
    <!-- Search for an existing annotation record -->
    <!-- Don't perform search until annotationTypeAsArray is ready -->
    <template is="dom-if" if="{{annotationTypeAsArray}}">
      <elastic-search
        client="[[client]]"
        elastic-type="{{annotationTypeAsArray}}"
        index="[[annotationIndex]]"
        query="{{buildAnnotationQuery(item, queryTemplate, currentUser)}}"
        results="{{originalSearchResult}}"
        last-error="{{error}}">
      </elastic-search>
    </template>

    <div class="layout horizontal">
      <paper-icon-button icon="flag"
        class$="annotation-icon dropdown-trigger [[getAnnotationClass(isItemOfInterest)]]"
        disabled="{{disableButtons}}"
        title="[[getAnnotationLabel(isItemOfInterest)]] (Click to Open Menu)"
        on-tap="openDropdownMenu">
      </paper-icon-button>

      <iron-dropdown id="dropdownMenu" focused horizontal-align="right" vertical-align="top">
        <paper-material class="dropdown-content" on-tap="stopPropagation">
          <paper-icon-item class$="annotation-option [[isSelected(isItemOfInterest, 0)]]" title="[[getAnnotationLabel(0)]]" on-tap="selectNoAnnotation">
            <iron-icon icon="flag" class="annotation-icon" item-icon></iron-icon>
            <paper-item-body>[[getAnnotationLabel(0)]]</paper-item-body>
          </paper-icon-item>
          <paper-icon-item class$="annotation-option [[isSelected(isItemOfInterest, 1)]]" title="[[getAnnotationLabel(1)]]" on-tap="selectPositiveAnnotation">
            <iron-icon icon="flag" class="annotation-icon positive" item-icon></iron-icon>
            <paper-item-body>[[getAnnotationLabel(1)]]</paper-item-body>
          </paper-icon-item>
          <paper-icon-item class$="annotation-option [[isSelected(isItemOfInterest, -1)]]" title="[[getAnnotationLabel(-1)]]" on-tap="selectNegativeAnnotation">
            <iron-icon icon="flag" class="annotation-icon negative" item-icon></iron-icon>
            <paper-item-body>[[getAnnotationLabel(-1)]]</paper-item-body>
          </paper-icon-item>

          <div class="layout horizontal">
            <paper-input class="flex" label="Justification" title="Justification" value="{{justification}}" always-float-label></paper-input>
            <paper-button class="dropdown-button" title="Save Annotation" on-tap="saveAnnotationAndCloseDropdownMenu">Save</paper-button>
          </div>
        </paper-material>
      </iron-dropdown>
    </div>

    <!-- Create or update annotation -->
    <elastic-update
      client="[[client]]"
      index="[[annotationIndex]]"
      elastic-type="[[annotationType]]"
      id="{{getAnnotationId(annotationResult)}}"
      body='{{annotationUpdateBody}}'
      results="{{annotationResult}}"
      last-error="{{error}}">
    </elastic-update>
    <elastic-create
      client="[[client]]"
      index="[[annotationIndex]]"
      elastic-type="[[annotationType]]"
      body='{{annotationCreateBody}}'
      results="{{annotationResult}}"
      last-error="{{error}}">
    </elastic-create>
  </template>
  <script>
  (function() {
    'use strict';
    /* globals _ */

    Polymer({
      is: 'annotate-record',

      properties: {
        /**
         * an instance of elasticsearch.Client which is connected to
         * an elasticsearch server
         */
        client: {
          type: Object
        },
        /**
         * the annotation index (database name)
         */
        annotationIndex: {
          type: String
        },
        /**
         * the annotation type
         */
        annotationType: {
          type: String
        },
        /**
         * query template to use to create annotation query
         */
        queryTemplate: {
          type: Object
        },
        /**
         * the record to add an associated annotation for,
         * based on current user and uri of the record
         */
        item: {
          type: Object,
          notify: true
        },
        /**
         * original result of query to find if there is an existing
         * annotation record
         */
        originalSearchResult: {
          type: Object,
          observer: 'transformOrigResult'
        },
        /**
         * where the result of the original search for an existing
         * annotation is stored (if found), or the result of a
         * successful creation or update
         */
        annotationResult: {
          type: Object,
          notify: true
        },
        /**
         * The annotation flag (positive, negative, or zero).
         */
        isItemOfInterest: {
          type: Number,
          value: 0,
          notify: true
        },
        /**
         * User currently logged in.
         */
        currentUser: {
          type: String,
          notify: true
        },
        /**
         * Document info to pass into the elastic-create component
         */
        annotationCreateBody: {
          type: Object,
          readOnly: true
        },
        /**
         * Info to update annotation and pass into the elastic-update
         * component
         */
        annotationUpdateBody: {
          type: Object,
          readOnly: true
        },
        disableButtons: {
          type: Boolean,
          value: true
        },
        annotationTypeAsArray: {
          type: Array,
          computed: 'computeTypeArray(annotationType)'
        },
        /**
         * The justification for the annotation.
         */
        justification: {
          type: String,
          value: '',
          notify: true
        },
        error: {
          type: Object
        }
      },
      computeTypeArray: function(annotationType) {
        return [annotationType];
      },
      getAnnotationId: function(annotationResult) {
        return (annotationResult ? annotationResult._id : undefined);
      },
      getAnnotationClass: function(isItemOfInterest) {
        return (isItemOfInterest > 0 ? 'positive' : (isItemOfInterest < 0 ? 'negative' : ''));
      },
      getAnnotationLabel: function(isItemOfInterest) {
        return (isItemOfInterest > 0 ? 'Interesting' : (isItemOfInterest < 0 ? 'Not Interesting' : 'No Opinion'));
      },
      getValuesForQuery: function(item, currentUser) {
        return [item._id, currentUser];
      },
      isSelected: function(isItemOfInterest, value) {
        return (isItemOfInterest === value ? 'selected' : '');
      },
      openDropdownMenu: function() {
        this.$.dropdownMenu.open();
      },
      saveAnnotation: function() {
        if(this.annotationResult && this.annotationResult._id) {
          this._setAnnotationUpdateBody({
            doc: {
              interest: this.isItemOfInterest,
              justification: this.justification
            }
          });
        } else {
          this._setAnnotationCreateBody({
            uri: this.item._id,
            user: this.currentUser,
            interest: this.isItemOfInterest,
            justification: this.justification
          });
        }
      },
      saveAnnotationAndCloseDropdownMenu: function() {
        this.$.dropdownMenu.close();
        this.saveAnnotation();
      },
      selectPositiveAnnotation: function() {
        this.isItemOfInterest = 1;
        this.saveAnnotation();
      },
      selectNegativeAnnotation: function() {
        this.isItemOfInterest = -1;
        this.saveAnnotation();
      },
      selectNoAnnotation: function() {
        this.isItemOfInterest = 0;
        this.saveAnnotation();
      },
      stopPropagation: function(event) {
        event.stopPropagation();
      },
      buildAnnotationQuery: function(item, queryTemplate, currentUser) {
        // ignore empty items, and don't rerun query if
        // query for this item has already been run

        if(!_.isEmpty(item) && queryTemplate && currentUser) {
          var self = this;

          // clear body for create/update components to ensure a
          // create or update isn't triggered yet
          this.annotationResult = undefined;
          this._setAnnotationCreateBody(undefined);
          this._setAnnotationUpdateBody(undefined);

          var values = self.getValuesForQuery(item, currentUser);
          var paths = queryTemplate.pathsToValues;

          _.each(paths, function(path, count) {
            var value = values[count];

            if(value) {
              _.set(queryTemplate.query, path, value);
            }
          });

          return {query: queryTemplate.query.query};
        }
      },
      transformOrigResult: function() {
        if(this.originalSearchResult) {
          this.disableButtons = false;

          if(this.originalSearchResult.hits.hits.length > 0) {
            this.annotationResult = this.originalSearchResult.hits.hits[0];
            /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
            this.isItemOfInterest = this.annotationResult._source.interest;
            this.justification = this.annotationResult._source.justification;
            /* jscs:enable requireCamelCaseOrUpperCaseIdentifiers */
          } else {
            this.isItemOfInterest = 0;
            this.justification = '';
          }

        } else {
          this.disableButtons = true;
          this.isItemOfInterest = 0;
          this.justification = '';
        }
      }
    });
  })();
  </script>
</dom-module>
