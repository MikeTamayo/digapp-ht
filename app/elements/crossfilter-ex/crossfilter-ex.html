<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<script src="../../bower_components/lodash/dist/lodash.min.js"></script>
<script src="../../bower_components/crossfilter/crossfilter.js" charset="utf-8"></script>
<dom-module id="crossfilter-ex">
  <template>
    <style>
      :host {
        display: block;
      }

    </style>
    <div class="layout horizontal">
      <bar-chart data="{{chartData}}" chart-filter="{{chartFilter}}" 
        y-axis-label="# of Offers" tooltip-label="offers"></bar-chart>
      <div id="mapDiv"></div>
    </div>
  </template>
  <script>
  (function() {
    'use strict';
    /* globals crossfilter */
    /* globals _ */

    Polymer({
      is: 'crossfilter-ex',
      properties: {
        originalResults: {
          type: Array,
          notify: true,
          observer: 'createGroupings'
        },
        records: {
          type: Object,
          value: function() {
            return {};
          },
          notify: true
        },
        mapData: {
          type: Array,
          value: function() {
            return [];
          },
          notify: true
        },
        chartFilter: {
          type: Object, 
          value: {begin: null, end: null},
          notify: true,
          observer: 'applyChartFilter'
        },
        mapFilter: {
          type: Array,
          value: function() {
            return [];
          },
          notify: true,
          observer: 'applyMapFilter'
        }
      },
      applyMapFilter: function() {
        var self = this;

        if(self.mapDimension && self.mapFilter.length === 0) {
          self.mapDimension.filterAll();
          self.records = {offer: this.fullRecordList.top(Infinity)}; 
        } else if(self.mapDimension && self.mapFilter.length > 0) {
          self.mapDimension.filter(function(item) {
            if(item !== null && item.address !== null) {
              return _.indexOf(self.mapFilter, item.address[0].addressLocality) !== -1;
            } else {
              return false;
            }
          });
          self.records = {offer: this.fullRecordList.top(Infinity)}; 
        }      

      },
      renderMap: function() {
        var children = Polymer.dom(this.$.mapDiv).children;
        var el = document.createElement('leaflet-wrapper');
        var self = this;

        el.mapData = this.mapData;
        el.mapFilter = this.mapFilter;

        el.addEventListener('map-filter-changed', function(){
          self.mapFilter = this.mapFilter;
          self.applyMapFilter();
        });

        // delete previous nodes if they exist
        for(var i = 0; i < children.length; i++) {
          Polymer.dom(this.$.mapDiv).removeChild(children[i]);
        }

        Polymer.dom(this.$.mapDiv).appendChild(el);
      },
      applyChartFilter: function() {
        var self = this;
        if(self.chartDimension) {
          self.chartDimension.filter(function(d) {
            // TODO: expect types other than dates
            var date = new Date(d);
            var beginDate = new Date(self.chartFilter.start);
            var endDate = new Date(self.chartFilter.end);
            return date >= beginDate && date <= endDate;
          });
          self.renderMap();
          self.records = {offer: this.fullRecordList.top(Infinity)};
        }
      },
      createMapDimension: function() {
        var Location = function(address, geo) {
          this.address = address;
          this.geo = geo;
        };

        Location.prototype.valueOf = function() {
          return this.address[0].addressLocality; 
        }; 

        this.mapDimension = this.crossFilterData.dimension(function(result) {

          if(!result._source.availableAtOrFrom.address || 
            !result._source.availableAtOrFrom.geo) {
            return null;
          }

          return new Location(result._source.availableAtOrFrom.address, 
            result._source.availableAtOrFrom.geo);
        });
      },
      createRecordsListDimension: function() {
        var Offer = function(result) {
          this.result = result;
        };

        Offer.prototype.valueOf = function() {
          return this.result._id;
        };

        this.fullRecordList = this.crossFilterData.dimension(function(result) {
          if(!result._source.availableAtOrFrom.address || 
            !result._source.availableAtOrFrom.geo) {
            return null;
          }
          return new Offer(result);
        });
      },
      createGroupings: function() {
        if(this.originalResults) {
          this.crossFilterData = crossfilter(this.originalResults);

          this.chartDimension = this.crossFilterData.dimension(function(result) {
            if(!result._source.availableAtOrFrom.address || 
              !result._source.availableAtOrFrom.geo) {
              return null;
            }
            return result._source.validFrom.substring(0, 10);
          });

          // define custom object and override valueOf for location dimension:
          // https://github.com/square/crossfilter/wiki/API-Reference#dimension
          this.createMapDimension();
          this.createRecordsListDimension();

          this.records = {offer: this.fullRecordList.top(Infinity)};
          this.mapData = this.mapDimension.group().reduceCount().all();
          this.chartData = this.chartDimension.group().reduceCount().all();

          this.renderMap();
        }
      }
    });
  })();
  </script>
</dom-module>
